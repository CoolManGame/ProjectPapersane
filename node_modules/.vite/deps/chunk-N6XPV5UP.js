import {
  __commonJS
} from "./chunk-VXSGCTFZ.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/puppeteer-core/lib/esm/third_party/mitt/index.js
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js
var EventEmitter = class {
  constructor() {
    this.eventsMap = /* @__PURE__ */ new Map();
    this.emitter = mitt(this.eventsMap);
  }
  on(event, handler) {
    this.emitter.on(event, handler);
    return this;
  }
  off(event, handler) {
    this.emitter.off(event, handler);
    return this;
  }
  removeListener(event, handler) {
    this.off(event, handler);
    return this;
  }
  addListener(event, handler) {
    this.on(event, handler);
    return this;
  }
  emit(event, eventData) {
    this.emitter.emit(event, eventData);
    return this.eventListenersCount(event) > 0;
  }
  once(event, handler) {
    const onceHandler = (eventData) => {
      handler(eventData);
      this.off(event, onceHandler);
    };
    return this.on(event, onceHandler);
  }
  listenerCount(event) {
    return this.eventListenersCount(event);
  }
  removeAllListeners(event) {
    if (event) {
      this.eventsMap.delete(event);
    } else {
      this.eventsMap.clear();
    }
    return this;
  }
  eventListenersCount(event) {
    var _a2;
    return ((_a2 = this.eventsMap.get(event)) == null ? void 0 : _a2.length) || 0;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js
var WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
  ["geolocation", "geolocation"],
  ["midi", "midi"],
  ["notifications", "notifications"],
  ["camera", "videoCapture"],
  ["microphone", "audioCapture"],
  ["background-sync", "backgroundSync"],
  ["ambient-light-sensor", "sensors"],
  ["accelerometer", "sensors"],
  ["gyroscope", "sensors"],
  ["magnetometer", "sensors"],
  ["accessibility-events", "accessibilityEvents"],
  ["clipboard-read", "clipboardReadWrite"],
  ["clipboard-write", "clipboardReadWrite"],
  ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
  ["payment-handler", "paymentHandler"],
  ["persistent-storage", "durableStorage"],
  ["idle-detection", "idleDetection"],
  ["midi-sysex", "midiSysex"]
]);
var Browser = class extends EventEmitter {
  constructor() {
    super();
  }
  _attach() {
    throw new Error("Not implemented");
  }
  _detach() {
    throw new Error("Not implemented");
  }
  get _targets() {
    throw new Error("Not implemented");
  }
  process() {
    throw new Error("Not implemented");
  }
  _getIsPageTargetCallback() {
    throw new Error("Not implemented");
  }
  createIncognitoBrowserContext() {
    throw new Error("Not implemented");
  }
  browserContexts() {
    throw new Error("Not implemented");
  }
  defaultBrowserContext() {
    throw new Error("Not implemented");
  }
  _disposeContext() {
    throw new Error("Not implemented");
  }
  wsEndpoint() {
    throw new Error("Not implemented");
  }
  newPage() {
    throw new Error("Not implemented");
  }
  _createPageInContext() {
    throw new Error("Not implemented");
  }
  targets() {
    throw new Error("Not implemented");
  }
  target() {
    throw new Error("Not implemented");
  }
  waitForTarget() {
    throw new Error("Not implemented");
  }
  async pages() {
    const contextPages = await Promise.all(this.browserContexts().map((context) => {
      return context.pages();
    }));
    return contextPages.reduce((acc, x) => {
      return acc.concat(x);
    }, []);
  }
  version() {
    throw new Error("Not implemented");
  }
  userAgent() {
    throw new Error("Not implemented");
  }
  close() {
    throw new Error("Not implemented");
  }
  disconnect() {
    throw new Error("Not implemented");
  }
  isConnected() {
    throw new Error("Not implemented");
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js
var BrowserContext = class extends EventEmitter {
  constructor() {
    super();
  }
  targets() {
    throw new Error("Not implemented");
  }
  waitForTarget() {
    throw new Error("Not implemented");
  }
  pages() {
    throw new Error("Not implemented");
  }
  isIncognito() {
    throw new Error("Not implemented");
  }
  overridePermissions() {
    throw new Error("Not implemented");
  }
  clearPermissionOverrides() {
    throw new Error("Not implemented");
  }
  newPage() {
    throw new Error("Not implemented");
  }
  browser() {
    throw new Error("Not implemented");
  }
  close() {
    throw new Error("Not implemented");
  }
  get id() {
    return void 0;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js
var assert = (value, message) => {
  if (!value) {
    throw new Error(message);
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ProtocolError_code;
var _ProtocolError_originalMessage;
var CustomError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};
var TimeoutError = class extends CustomError {
};
var ProtocolError = class extends CustomError {
  constructor() {
    super(...arguments);
    _ProtocolError_code.set(this, void 0);
    _ProtocolError_originalMessage.set(this, "");
  }
  set code(code) {
    __classPrivateFieldSet(this, _ProtocolError_code, code, "f");
  }
  get code() {
    return __classPrivateFieldGet(this, _ProtocolError_code, "f");
  }
  set originalMessage(originalMessage) {
    __classPrivateFieldSet(this, _ProtocolError_originalMessage, originalMessage, "f");
  }
  get originalMessage() {
    return __classPrivateFieldGet(this, _ProtocolError_originalMessage, "f");
  }
};
_ProtocolError_code = /* @__PURE__ */ new WeakMap(), _ProtocolError_originalMessage = /* @__PURE__ */ new WeakMap();
var TargetCloseError = class extends ProtocolError {
};
var errors = Object.freeze({
  TimeoutError,
  ProtocolError
});

// node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Deferred_instances;
var _Deferred_isResolved;
var _Deferred_isRejected;
var _Deferred_value;
var _Deferred_resolver;
var _Deferred_taskPromise;
var _Deferred_timeoutId;
var _Deferred_finish;
var Deferred = class {
  constructor(opts) {
    _Deferred_instances.add(this);
    _Deferred_isResolved.set(this, false);
    _Deferred_isRejected.set(this, false);
    _Deferred_value.set(this, void 0);
    _Deferred_resolver.set(this, () => {
    });
    _Deferred_taskPromise.set(this, new Promise((resolve) => {
      __classPrivateFieldSet2(this, _Deferred_resolver, resolve, "f");
    }));
    _Deferred_timeoutId.set(this, void 0);
    __classPrivateFieldSet2(this, _Deferred_timeoutId, opts && opts.timeout > 0 ? setTimeout(() => {
      this.reject(new TimeoutError(opts.message));
    }, opts.timeout) : void 0, "f");
  }
  resolve(value) {
    if (__classPrivateFieldGet2(this, _Deferred_isRejected, "f") || __classPrivateFieldGet2(this, _Deferred_isResolved, "f")) {
      return;
    }
    __classPrivateFieldSet2(this, _Deferred_isResolved, true, "f");
    __classPrivateFieldGet2(this, _Deferred_instances, "m", _Deferred_finish).call(this, value);
  }
  reject(error) {
    if (__classPrivateFieldGet2(this, _Deferred_isRejected, "f") || __classPrivateFieldGet2(this, _Deferred_isResolved, "f")) {
      return;
    }
    __classPrivateFieldSet2(this, _Deferred_isRejected, true, "f");
    __classPrivateFieldGet2(this, _Deferred_instances, "m", _Deferred_finish).call(this, error);
  }
  resolved() {
    return __classPrivateFieldGet2(this, _Deferred_isResolved, "f");
  }
  finished() {
    return __classPrivateFieldGet2(this, _Deferred_isResolved, "f") || __classPrivateFieldGet2(this, _Deferred_isRejected, "f");
  }
  value() {
    return __classPrivateFieldGet2(this, _Deferred_value, "f");
  }
  async valueOrThrow() {
    await __classPrivateFieldGet2(this, _Deferred_taskPromise, "f");
    if (__classPrivateFieldGet2(this, _Deferred_isRejected, "f")) {
      throw __classPrivateFieldGet2(this, _Deferred_value, "f");
    }
    return __classPrivateFieldGet2(this, _Deferred_value, "f");
  }
  static create(opts) {
    return new Deferred(opts);
  }
  static async race(awaitables) {
    const deferredWithTimeout = /* @__PURE__ */ new Set();
    try {
      const promises = awaitables.map((value) => {
        if (value instanceof Deferred) {
          if (__classPrivateFieldGet2(value, _Deferred_timeoutId, "f")) {
            deferredWithTimeout.add(value);
          }
          return value.valueOrThrow();
        }
        return value;
      });
      return await Promise.race(promises);
    } finally {
      for (const deferred of deferredWithTimeout) {
        deferred.reject(new Error("Timeout cleared"));
      }
    }
  }
};
_Deferred_isResolved = /* @__PURE__ */ new WeakMap(), _Deferred_isRejected = /* @__PURE__ */ new WeakMap(), _Deferred_value = /* @__PURE__ */ new WeakMap(), _Deferred_resolver = /* @__PURE__ */ new WeakMap(), _Deferred_taskPromise = /* @__PURE__ */ new WeakMap(), _Deferred_timeoutId = /* @__PURE__ */ new WeakMap(), _Deferred_instances = /* @__PURE__ */ new WeakSet(), _Deferred_finish = function _Deferred_finish2(value) {
  clearTimeout(__classPrivateFieldGet2(this, _Deferred_timeoutId, "f"));
  __classPrivateFieldSet2(this, _Deferred_value, value, "f");
  __classPrivateFieldGet2(this, _Deferred_resolver, "f").call(this);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/environment.js
var isNode = !!(typeof process !== "undefined" && process.version);
var DEFERRED_PROMISE_DEBUG_TIMEOUT = typeof process !== "undefined" && typeof process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"] !== "undefined" ? Number(process.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"]) : -1;

// node_modules/puppeteer-core/lib/esm/puppeteer/util/DebuggableDeferred.js
function createDebuggableDeferred(message) {
  if (DEFERRED_PROMISE_DEBUG_TIMEOUT > 0) {
    return Deferred.create({
      message,
      timeout: DEFERRED_PROMISE_DEBUG_TIMEOUT
    });
  }
  return Deferred.create();
}

// node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js
var DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;
var HTTPRequest = class {
  get client() {
    throw new Error("Not implemented");
  }
  constructor() {
    this._requestId = "";
    this._failureText = null;
    this._response = null;
    this._fromMemoryCache = false;
    this._redirectChain = [];
  }
  url() {
    throw new Error("Not implemented");
  }
  continueRequestOverrides() {
    throw new Error("Not implemented");
  }
  responseForRequest() {
    throw new Error("Not implemented");
  }
  abortErrorReason() {
    throw new Error("Not implemented");
  }
  interceptResolutionState() {
    throw new Error("Not implemented");
  }
  isInterceptResolutionHandled() {
    throw new Error("Not implemented");
  }
  enqueueInterceptAction() {
    throw new Error("Not implemented");
  }
  async finalizeInterceptions() {
    throw new Error("Not implemented");
  }
  resourceType() {
    throw new Error("Not implemented");
  }
  method() {
    throw new Error("Not implemented");
  }
  postData() {
    throw new Error("Not implemented");
  }
  headers() {
    throw new Error("Not implemented");
  }
  response() {
    throw new Error("Not implemented");
  }
  frame() {
    throw new Error("Not implemented");
  }
  isNavigationRequest() {
    throw new Error("Not implemented");
  }
  initiator() {
    throw new Error("Not implemented");
  }
  redirectChain() {
    throw new Error("Not implemented");
  }
  failure() {
    throw new Error("Not implemented");
  }
  async continue() {
    throw new Error("Not implemented");
  }
  async respond() {
    throw new Error("Not implemented");
  }
  async abort() {
    throw new Error("Not implemented");
  }
};
var InterceptResolutionAction;
(function(InterceptResolutionAction2) {
  InterceptResolutionAction2["Abort"] = "abort";
  InterceptResolutionAction2["Respond"] = "respond";
  InterceptResolutionAction2["Continue"] = "continue";
  InterceptResolutionAction2["Disabled"] = "disabled";
  InterceptResolutionAction2["None"] = "none";
  InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
})(InterceptResolutionAction || (InterceptResolutionAction = {}));
function headersArray(headers) {
  const result = [];
  for (const name in headers) {
    const value = headers[name];
    if (!Object.is(value, void 0)) {
      const values = Array.isArray(value) ? value : [value];
      result.push(...values.map((value2) => {
        return { name, value: value2 + "" };
      }));
    }
  }
  return result;
}
var STATUS_TEXTS = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "Switch Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};

// node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
}
function isErrnoException(obj) {
  return isErrorLike(obj) && ("errno" in obj || "code" in obj || "path" in obj || "syscall" in obj);
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js
var debugModule = null;
async function importDebug() {
  if (!debugModule) {
    debugModule = (await import("./browser-442T2B4M.js")).default;
  }
  return debugModule;
}
var debug = (prefix) => {
  if (isNode) {
    return async (...logArgs) => {
      if (captureLogs) {
        capturedLogs.push(prefix + logArgs);
      }
      (await importDebug())(prefix)(logArgs);
    };
  }
  return (...logArgs) => {
    const debugLevel = globalThis.__PUPPETEER_DEBUG;
    if (!debugLevel) {
      return;
    }
    const everythingShouldBeLogged = debugLevel === "*";
    const prefixMatchesDebugLevel = everythingShouldBeLogged || (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
    if (!prefixMatchesDebugLevel) {
      return;
    }
    console.log(`${prefix}:`, ...logArgs);
  };
};
var capturedLogs = [];
var captureLogs = false;
function setLogCapture(value) {
  capturedLogs = [];
  captureLogs = value;
}
function getCapturedLogs() {
  return capturedLogs;
}

// node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js
var AsyncIterableUtil = class {
  static async *map(iterable, map) {
    for await (const value of iterable) {
      yield await map(value);
    }
  }
  static async *flatMap(iterable, map) {
    for await (const value of iterable) {
      yield* map(value);
    }
  }
  static async collect(iterable) {
    const result = [];
    for await (const value of iterable) {
      result.push(value);
    }
    return result;
  }
  static async first(iterable) {
    for await (const value of iterable) {
      return value;
    }
    return;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LazyArg_get;
var LazyArg = class {
  constructor(get) {
    _LazyArg_get.set(this, void 0);
    __classPrivateFieldSet3(this, _LazyArg_get, get, "f");
  }
  async get(context) {
    return __classPrivateFieldGet3(this, _LazyArg_get, "f").call(this, context);
  }
};
_LazyArg_get = /* @__PURE__ */ new WeakMap();
LazyArg.create = (get) => {
  return new LazyArg(get);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/AriaQueryHandler.js
var _a;
var queryAXTree = async (client, element, accessibleName, role) => {
  const { nodes } = await client.send("Accessibility.queryAXTree", {
    objectId: element.id,
    accessibleName,
    role
  });
  return nodes.filter((node) => {
    return !node.role || node.role.value !== "StaticText";
  });
};
var KNOWN_ATTRIBUTES = Object.freeze(["name", "role"]);
var isKnownAttribute = (attribute) => {
  return KNOWN_ATTRIBUTES.includes(attribute);
};
var normalizeValue = (value) => {
  return value.replace(/ +/g, " ").trim();
};
var ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
var parseARIASelector = (selector) => {
  const queryOptions = {};
  const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
    attribute = attribute.trim();
    assert(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
    queryOptions[attribute] = normalizeValue(value);
    return "";
  });
  if (defaultName && !queryOptions.name) {
    queryOptions.name = normalizeValue(defaultName);
  }
  return queryOptions;
};
var ARIAQueryHandler = class extends QueryHandler {
  static async *queryAll(element, selector) {
    const context = element.executionContext();
    const { name, role } = parseARIASelector(selector);
    const results = await queryAXTree(context._client, element, name, role);
    const world = context._world;
    yield* AsyncIterableUtil.map(results, (node) => {
      return world.adoptBackendNode(node.backendDOMNodeId);
    });
  }
};
_a = ARIAQueryHandler;
ARIAQueryHandler.querySelector = async (node, selector, { ariaQuerySelector }) => {
  return ariaQuerySelector(node, selector);
};
ARIAQueryHandler.queryOne = async (element, selector) => {
  var _a2;
  return (_a2 = await AsyncIterableUtil.first(_a.queryAll(element, selector))) != null ? _a2 : null;
};

// node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js
var createdFunctions = /* @__PURE__ */ new Map();
var createFunction = (functionValue) => {
  let fn = createdFunctions.get(functionValue);
  if (fn) {
    return fn;
  }
  fn = new Function(`return ${functionValue}`)();
  createdFunctions.set(functionValue, fn);
  return fn;
};
function stringifyFunction(fn) {
  let value = fn.toString();
  try {
    new Function(`(${value})`);
  } catch {
    let prefix = "function ";
    if (value.startsWith("async ")) {
      prefix = `async ${prefix}`;
      value = value.substring("async ".length);
    }
    value = `${prefix}${value}`;
    try {
      new Function(`(${value})`);
    } catch {
      throw new Error("Passed function cannot be serialized!");
    }
  }
  return value;
}
var interpolateFunction = (fn, replacements) => {
  let value = stringifyFunction(fn);
  for (const [name, jsValue] of Object.entries(replacements)) {
    value = value.replace(
      new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, "g"),
      `(${jsValue})`
    );
  }
  return createFunction(value);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/generated/injected.js
var source = '"use strict";var C=Object.defineProperty;var ne=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var se=Object.prototype.hasOwnProperty;var f=(t,e)=>{for(var n in e)C(t,n,{get:e[n],enumerable:!0})},ie=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of oe(e))!se.call(t,o)&&o!==n&&C(t,o,{get:()=>e[o],enumerable:!(r=ne(e,o))||r.enumerable});return t};var le=t=>ie(C({},"__esModule",{value:!0}),t);var Oe={};f(Oe,{default:()=>Re});module.exports=le(Oe);var T=class extends Error{constructor(e){super(e),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor)}},S=class extends T{},I=class extends T{#e;#t="";set code(e){this.#e=e}get code(){return this.#e}set originalMessage(e){this.#t=e}get originalMessage(){return this.#t}};var qe=Object.freeze({TimeoutError:S,ProtocolError:I});var a=class{#e=!1;#t=!1;#n;#r=()=>{};#o=new Promise(e=>{this.#r=e});#s;constructor(e){this.#s=e&&e.timeout>0?setTimeout(()=>{this.reject(new S(e.message))},e.timeout):void 0}#i(e){clearTimeout(this.#s),this.#n=e,this.#r()}resolve(e){this.#t||this.#e||(this.#e=!0,this.#i(e))}reject(e){this.#t||this.#e||(this.#t=!0,this.#i(e))}resolved(){return this.#e}finished(){return this.#e||this.#t}value(){return this.#n}async valueOrThrow(){if(await this.#o,this.#t)throw this.#n;return this.#n}static create(e){return new a(e)}static async race(e){let n=new Set;try{let r=e.map(o=>o instanceof a?(o.#s&&n.add(o),o.valueOrThrow()):o);return await Promise.race(r)}finally{for(let r of n)r.reject(new Error("Timeout cleared"))}}};var G=new Map,X=t=>{let e=G.get(t);return e||(e=new Function(`return ${t}`)(),G.set(t,e),e)};var R={};f(R,{ariaQuerySelector:()=>ae,ariaQuerySelectorAll:()=>k});var ae=(t,e)=>window.__ariaQuerySelector(t,e),k=async function*(t,e){yield*await window.__ariaQuerySelectorAll(t,e)};var q={};f(q,{customQuerySelectors:()=>M});var O=class{#e=new Map;register(e,n){if(!n.queryOne&&n.queryAll){let r=n.queryAll;n.queryOne=(o,i)=>{for(let s of r(o,i))return s;return null}}else if(n.queryOne&&!n.queryAll){let r=n.queryOne;n.queryAll=(o,i)=>{let s=r(o,i);return s?[s]:[]}}else if(!n.queryOne||!n.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:n.queryOne,querySelectorAll:n.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},M=new O;var _={};f(_,{pierceQuerySelector:()=>ce,pierceQuerySelectorAll:()=>ue});var ce=(t,e)=>{let n=null,r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&!n&&s.matches(e)&&(n=s)}while(!n&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n},ue=(t,e)=>{let n=[],r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&s.matches(e)&&n.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n};var m=(t,e)=>{if(!t)throw new Error(e)};var P=class{#e;#t;#n;#r;constructor(e,n){this.#e=e,this.#t=n}async start(){let e=this.#r=a.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=new MutationObserver(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())}),this.#n.observe(this.#t,{childList:!0,subtree:!0,attributes:!0})}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped")),this.#n&&(this.#n.disconnect(),this.#n=void 0)}result(){return m(this.#r,"Polling never started."),this.#r.valueOrThrow()}},E=class{#e;#t;constructor(e){this.#e=e}async start(){let e=this.#t=a.create(),n=await this.#e();if(n){e.resolve(n);return}let r=async()=>{if(e.finished())return;let o=await this.#e();if(!o){window.requestAnimationFrame(r);return}e.resolve(o),await this.stop()};window.requestAnimationFrame(r)}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped"))}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}},x=class{#e;#t;#n;#r;constructor(e,n){this.#e=e,this.#t=n}async start(){let e=this.#r=a.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=setInterval(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())},this.#t)}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped")),this.#n&&(clearInterval(this.#n),this.#n=void 0)}result(){return m(this.#r,"Polling never started."),this.#r.valueOrThrow()}};var H={};f(H,{pQuerySelector:()=>Ie,pQuerySelectorAll:()=>re});var u=class{static async*map(e,n){for await(let r of e)yield await n(r)}static async*flatMap(e,n){for await(let r of e)yield*n(r)}static async collect(e){let n=[];for await(let r of e)n.push(r);return n}static async first(e){for await(let n of e)return n}};var p={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,"pseudo-element":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6+)\\))?/gu,"pseudo-class":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6+)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},fe=new Set(["combinator","comma"]);var de=t=>{switch(t){case"pseudo-element":case"pseudo-class":return new RegExp(p[t].source.replace("(?<argument>\\xB6+)","(?<argument>.+)"),"gu");default:return p[t]}};function me(t,e){let n=0,r="";for(;e<t.length;e++){let o=t[e];switch(o){case"(":++n;break;case")":--n;break}if(r+=o,n===0)return r}return r}function he(t,e=p){if(!t)return[];let n=[t];for(let[o,i]of Object.entries(e))for(let s=0;s<n.length;s++){let l=n[s];if(typeof l!="string")continue;i.lastIndex=0;let c=i.exec(l);if(!c)continue;let h=c.index-1,d=[],V=c[0],B=l.slice(0,h+1);B&&d.push(B),d.push({...c.groups,type:o,content:V});let z=l.slice(h+V.length+1);z&&d.push(z),n.splice(s,1,...d)}let r=0;for(let o of n)switch(typeof o){case"string":throw new Error(`Unexpected sequence ${o} found at index ${r}`);case"object":r+=o.content.length,o.pos=[r-o.content.length,r],fe.has(o.type)&&(o.content=o.content.trim()||" ");break}return n}var pe=/([\'"])([^\\\\\\n]+?)\\1/g,ye=/\\\\./g;function K(t,e=p){if(t=t.trim(),t==="")return[];let n=[];t=t.replace(ye,(i,s)=>(n.push({value:i,offset:s}),"\\uE000".repeat(i.length))),t=t.replace(pe,(i,s,l,c)=>(n.push({value:i,offset:c}),`${s}${"\\uE001".repeat(l.length)}${s}`));{let i=0,s;for(;(s=t.indexOf("(",i))>-1;){let l=me(t,s);n.push({value:l,offset:s}),t=`${t.substring(0,s)}(${"\\xB6".repeat(l.length-2)})${t.substring(s+l.length)}`,i=s+l.length}}let r=he(t,e),o=new Set;for(let i of n.reverse())for(let s of r){let{offset:l,value:c}=i;if(!(s.pos[0]<=l&&l+c.length<=s.pos[1]))continue;let{content:h}=s,d=l-s.pos[0];s.content=h.slice(0,d)+c+h.slice(d+c.length),s.content!==h&&o.add(s)}for(let i of o){let s=de(i.type);if(!s)throw new Error(`Unknown token type: ${i.type}`);s.lastIndex=0;let l=s.exec(i.content);if(!l)throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);Object.assign(i,l.groups)}return r}function*N(t,e){switch(t.type){case"list":for(let n of t.list)yield*N(n,t);break;case"complex":yield*N(t.left,t),yield*N(t.right,t);break;case"compound":yield*t.list.map(n=>[n,t]);break;default:yield[t,e]}}function y(t){let e;return Array.isArray(t)?e=t:e=[...N(t)].map(([n])=>n),e.map(n=>n.content).join("")}p.combinator=/\\s*(>>>>?|[\\s>+~])\\s*/g;var ge=/\\\\[\\s\\S]/g,we=t=>{if(t.length>1){for(let e of[\'"\',"\'"])if(!(!t.startsWith(e)||!t.endsWith(e)))return t.slice(e.length,-e.length).replace(ge,n=>n.slice(1))}return t};function Y(t){let e=!0,n=K(t);if(n.length===0)return[[],e];let r=[],o=[r],i=[o],s=[];for(let l of n){switch(l.type){case"combinator":switch(l.content){case">>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>"),o.push(r);continue;case">>>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>>"),o.push(r);continue}break;case"pseudo-element":if(!l.name.startsWith("-p-"))break;e=!1,s.length&&(r.push(y(s)),s.splice(0)),r.push({name:l.name.slice(3),value:we(l.argument??"")});continue;case"comma":s.length&&(r.push(y(s)),s.splice(0)),r=[],o=[r],i.push(o);continue}s.push(l)}return s.length&&r.push(y(s)),[i,e]}var Q={};f(Q,{textQuerySelectorAll:()=>b});var Se=new Set(["checkbox","image","radio"]),be=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!Se.has(t.type),Te=new Set(["SCRIPT","STYLE"]),w=t=>!Te.has(t.nodeName)&&!document.head?.contains(t),D=new WeakMap,Z=t=>{for(;t;)D.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},J=new WeakSet,Pe=new MutationObserver(t=>{for(let e of t)Z(e.target)}),g=t=>{let e=D.get(t);if(e||(e={full:"",immediate:[]},!w(t)))return e;let n="";if(be(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",r=>{Z(r.target)},{once:!0,capture:!0});else{for(let r=t.firstChild;r;r=r.nextSibling){if(r.nodeType===Node.TEXT_NODE){e.full+=r.nodeValue??"",n+=r.nodeValue??"";continue}n&&e.immediate.push(n),n="",r.nodeType===Node.ELEMENT_NODE&&(e.full+=g(r).full)}n&&e.immediate.push(n),t instanceof Element&&t.shadowRoot&&(e.full+=g(t.shadowRoot).full),J.has(t)||(Pe.observe(t,{childList:!0,characterData:!0}),J.add(t))}return D.set(t,e),e};var b=function*(t,e){let n=!1;for(let r of t.childNodes)if(r instanceof Element&&w(r)){let o;r.shadowRoot?o=b(r.shadowRoot,e):o=b(r,e);for(let i of o)yield i,n=!0}n||t instanceof Element&&w(t)&&g(t).full.includes(e)&&(yield t)};var $={};f($,{checkVisibility:()=>xe,pierce:()=>A,pierceAll:()=>L});var Ee=["hidden","collapse"],xe=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let n=t.nodeType===Node.TEXT_NODE?t.parentElement:t,r=window.getComputedStyle(n),o=r&&!Ee.includes(r.visibility)&&!Ne(n);return e===o?t:!1};function Ne(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var Ae=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*A(t){Ae(t)?yield t.shadowRoot:yield t}function*L(t){t=A(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let n of e){let r;for(;r=n.nextNode();)r.shadowRoot&&(yield r.shadowRoot,e.push(document.createTreeWalker(r.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var j={};f(j,{xpathQuerySelectorAll:()=>U});var U=function*(t,e){let r=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),o;for(;o=r.iterateNext();)yield o};var ve=/[-\\w\\P{ASCII}*]/,ee=t=>"querySelectorAll"in t,v=class extends Error{constructor(e,n){super(`${e} is not a valid selector: ${n}`)}},F=class{#e;#t;#n=[];#r=void 0;elements;constructor(e,n,r){this.elements=[e],this.#e=n,this.#t=r,this.#o()}async run(){if(typeof this.#r=="string")switch(this.#r.trimStart()){case":scope":this.#o();break}for(;this.#r!==void 0;this.#o()){let e=this.#r,n=this.#e;typeof e=="string"?e[0]&&ve.test(e[0])?this.elements=u.flatMap(this.elements,async function*(r){ee(r)&&(yield*r.querySelectorAll(e))}):this.elements=u.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!ee(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let i of r.parentElement.children)if(++o,i===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=u.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*b(r,e.value);break;case"xpath":yield*U(r,e.value);break;case"aria":yield*k(r,e.value);break;default:let o=M.get(e.name);if(!o)throw new v(n,`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#o(){if(this.#n.length!==0){this.#r=this.#n.shift();return}if(this.#t.length===0){this.#r=void 0;return}let e=this.#t.shift();switch(e){case">>>>":{this.elements=u.flatMap(this.elements,A),this.#o();break}case">>>":{this.elements=u.flatMap(this.elements,L),this.#o();break}default:this.#n=e,this.#o();break}}},W=class{#e=new WeakMap;calculate(e,n=[]){if(e===null)return n;e instanceof ShadowRoot&&(e=e.host);let r=this.#e.get(e);if(r)return[...r,...n];let o=0;for(let s=e.previousSibling;s;s=s.previousSibling)++o;let i=this.calculate(e.parentNode,[o]);return this.#e.set(e,i),[...i,...n]}},te=(t,e)=>{if(t.length+e.length===0)return 0;let[n=-1,...r]=t,[o=-1,...i]=e;return n===o?te(r,i):n<o?-1:1},Ce=async function*(t){let e=new Set;for await(let r of t)e.add(r);let n=new W;yield*[...e.values()].map(r=>[r,n.calculate(r)]).sort(([,r],[,o])=>te(r,o)).map(([r])=>r)},re=function(t,e){let n,r;try{[n,r]=Y(e)}catch{return t.querySelectorAll(e)}if(r)return t.querySelectorAll(e);if(n.some(o=>{let i=0;return o.some(s=>(typeof s=="string"?++i:i=0,i>1))}))throw new v(e,"Multiple deep combinators found in sequence.");return Ce(u.flatMap(n,o=>{let i=new F(t,e,o);return i.run(),i.elements}))},Ie=async function(t,e){for await(let n of re(t,e))return n;return null};var ke=Object.freeze({...R,...q,..._,...H,...Q,...$,...j,Deferred:a,createFunction:X,createTextContent:g,IntervalPoller:x,isSuitableNodeForTextMatching:w,MutationPoller:P,RAFPoller:E}),Re=ke;\n';

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _ScriptInjector_instances;
var _ScriptInjector_updated;
var _ScriptInjector_amendments;
var _ScriptInjector_update;
var _ScriptInjector_get;
var ScriptInjector = class {
  constructor() {
    _ScriptInjector_instances.add(this);
    _ScriptInjector_updated.set(this, false);
    _ScriptInjector_amendments.set(this, /* @__PURE__ */ new Set());
  }
  append(statement) {
    __classPrivateFieldGet4(this, _ScriptInjector_instances, "m", _ScriptInjector_update).call(this, () => {
      __classPrivateFieldGet4(this, _ScriptInjector_amendments, "f").add(statement);
    });
  }
  pop(statement) {
    __classPrivateFieldGet4(this, _ScriptInjector_instances, "m", _ScriptInjector_update).call(this, () => {
      __classPrivateFieldGet4(this, _ScriptInjector_amendments, "f").delete(statement);
    });
  }
  inject(inject, force = false) {
    if (__classPrivateFieldGet4(this, _ScriptInjector_updated, "f") || force) {
      inject(__classPrivateFieldGet4(this, _ScriptInjector_instances, "m", _ScriptInjector_get).call(this));
    }
    __classPrivateFieldSet4(this, _ScriptInjector_updated, false, "f");
  }
};
_ScriptInjector_updated = /* @__PURE__ */ new WeakMap(), _ScriptInjector_amendments = /* @__PURE__ */ new WeakMap(), _ScriptInjector_instances = /* @__PURE__ */ new WeakSet(), _ScriptInjector_update = function _ScriptInjector_update2(callback) {
  callback();
  __classPrivateFieldSet4(this, _ScriptInjector_updated, true, "f");
}, _ScriptInjector_get = function _ScriptInjector_get2() {
  return `(() => {
      const module = {};
      ${source}
      ${[...__classPrivateFieldGet4(this, _ScriptInjector_amendments, "f")].map((statement) => {
    return `(${statement})(module.exports.default);`;
  }).join("")}
      return module.exports.default;
    })()`;
};
var scriptInjector = new ScriptInjector();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js
var __classPrivateFieldGet5 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __setFunctionName = function(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var _CustomQueryHandlerRegistry_handlers;
var CustomQueryHandlerRegistry = class {
  constructor() {
    _CustomQueryHandlerRegistry_handlers.set(this, /* @__PURE__ */ new Map());
  }
  get(name) {
    const handler = __classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").get(name);
    return handler ? handler[1] : void 0;
  }
  register(name, handler) {
    var _a2;
    if (__classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").has(name)) {
      throw new Error(`Cannot register over existing handler: ${name}`);
    }
    assert(!__classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").has(name), `Cannot register over existing handler: ${name}`);
    assert(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
    assert(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
    const Handler = (_a2 = class extends QueryHandler {
    }, __setFunctionName(_a2, "Handler"), _a2.querySelectorAll = interpolateFunction((node, selector, PuppeteerUtil) => {
      return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
    }, { name: JSON.stringify(name) }), _a2.querySelector = interpolateFunction((node, selector, PuppeteerUtil) => {
      return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
    }, { name: JSON.stringify(name) }), _a2);
    const registerScript = interpolateFunction((PuppeteerUtil) => {
      PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
        queryAll: PLACEHOLDER("queryAll"),
        queryOne: PLACEHOLDER("queryOne")
      });
    }, {
      name: JSON.stringify(name),
      queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
      queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
    }).toString();
    __classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").set(name, [registerScript, Handler]);
    scriptInjector.append(registerScript);
  }
  unregister(name) {
    const handler = __classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").get(name);
    if (!handler) {
      throw new Error(`Cannot unregister unknown handler: ${name}`);
    }
    scriptInjector.pop(handler[0]);
    __classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").delete(name);
  }
  names() {
    return [...__classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").keys()];
  }
  clear() {
    for (const [registerScript] of __classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f")) {
      scriptInjector.pop(registerScript);
    }
    __classPrivateFieldGet5(this, _CustomQueryHandlerRegistry_handlers, "f").clear();
  }
};
_CustomQueryHandlerRegistry_handlers = /* @__PURE__ */ new WeakMap();
var customQueryHandlers = new CustomQueryHandlerRegistry();
function registerCustomQueryHandler(name, handler) {
  customQueryHandlers.register(name, handler);
}
function unregisterCustomQueryHandler(name) {
  customQueryHandlers.unregister(name);
}
function customQueryHandlerNames() {
  return customQueryHandlers.names();
}
function clearCustomQueryHandlers() {
  customQueryHandlers.clear();
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js
var PierceQueryHandler = class extends QueryHandler {
};
PierceQueryHandler.querySelector = (element, selector, { pierceQuerySelector }) => {
  return pierceQuerySelector(element, selector);
};
PierceQueryHandler.querySelectorAll = (element, selector, { pierceQuerySelectorAll }) => {
  return pierceQuerySelectorAll(element, selector);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js
var PQueryHandler = class extends QueryHandler {
};
PQueryHandler.querySelectorAll = (element, selector, { pQuerySelectorAll }) => {
  return pQuerySelectorAll(element, selector);
};
PQueryHandler.querySelector = (element, selector, { pQuerySelector }) => {
  return pQuerySelector(element, selector);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js
var TextQueryHandler = class extends QueryHandler {
};
TextQueryHandler.querySelectorAll = (element, selector, { textQuerySelectorAll }) => {
  return textQuerySelectorAll(element, selector);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js
var XPathQueryHandler = class extends QueryHandler {
};
XPathQueryHandler.querySelectorAll = (element, selector, { xpathQuerySelectorAll }) => {
  return xpathQuerySelectorAll(element, selector);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js
var BUILTIN_QUERY_HANDLERS = Object.freeze({
  aria: ARIAQueryHandler,
  pierce: PierceQueryHandler,
  xpath: XPathQueryHandler,
  text: TextQueryHandler
});
var QUERY_SEPARATORS = ["=", "/"];
function getQueryHandlerAndSelector(selector) {
  for (const handlerMap of [
    customQueryHandlers.names().map((name) => {
      return [name, customQueryHandlers.get(name)];
    }),
    Object.entries(BUILTIN_QUERY_HANDLERS)
  ]) {
    for (const [name, QueryHandler2] of handlerMap) {
      for (const separator of QUERY_SEPARATORS) {
        const prefix = `${name}${separator}`;
        if (selector.startsWith(prefix)) {
          selector = selector.slice(prefix.length);
          return { updatedSelector: selector, QueryHandler: QueryHandler2 };
        }
      }
    }
  }
  return { updatedSelector: selector, QueryHandler: PQueryHandler };
}

// node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js
var JSHandle = class {
  constructor() {
  }
  get disposed() {
    throw new Error("Not implemented");
  }
  executionContext() {
    throw new Error("Not implemented");
  }
  get client() {
    throw new Error("Not implemented");
  }
  async evaluate() {
    throw new Error("Not implemented");
  }
  async evaluateHandle() {
    throw new Error("Not implemented");
  }
  async getProperty() {
    throw new Error("Not implemented");
  }
  async getProperties() {
    throw new Error("Not implemented");
  }
  async jsonValue() {
    throw new Error("Not implemented");
  }
  asElement() {
    throw new Error("Not implemented");
  }
  async dispose() {
    throw new Error("Not implemented");
  }
  toString() {
    throw new Error("Not implemented");
  }
  get id() {
    throw new Error("Not implemented");
  }
  remoteObject() {
    throw new Error("Not implemented");
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/JSHandle.js
var __classPrivateFieldGet6 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet5 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _CDPJSHandle_disposed;
var _CDPJSHandle_context;
var _CDPJSHandle_remoteObject;
var CDPJSHandle = class extends JSHandle {
  get disposed() {
    return __classPrivateFieldGet6(this, _CDPJSHandle_disposed, "f");
  }
  constructor(context, remoteObject) {
    super();
    _CDPJSHandle_disposed.set(this, false);
    _CDPJSHandle_context.set(this, void 0);
    _CDPJSHandle_remoteObject.set(this, void 0);
    __classPrivateFieldSet5(this, _CDPJSHandle_context, context, "f");
    __classPrivateFieldSet5(this, _CDPJSHandle_remoteObject, remoteObject, "f");
  }
  executionContext() {
    return __classPrivateFieldGet6(this, _CDPJSHandle_context, "f");
  }
  get client() {
    return __classPrivateFieldGet6(this, _CDPJSHandle_context, "f")._client;
  }
  async evaluate(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
    return await this.executionContext().evaluate(pageFunction, this, ...args);
  }
  async evaluateHandle(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
    return await this.executionContext().evaluateHandle(pageFunction, this, ...args);
  }
  async getProperty(propertyName) {
    return this.evaluateHandle((object, propertyName2) => {
      return object[propertyName2];
    }, propertyName);
  }
  async getProperties() {
    assert(__classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f").objectId);
    const response = await this.client.send("Runtime.getProperties", {
      objectId: __classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f").objectId,
      ownProperties: true
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.result) {
      if (!property.enumerable || !property.value) {
        continue;
      }
      result.set(property.name, createJSHandle(__classPrivateFieldGet6(this, _CDPJSHandle_context, "f"), property.value));
    }
    return result;
  }
  async jsonValue() {
    if (!__classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f").objectId) {
      return valueFromRemoteObject(__classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f"));
    }
    const value = await this.evaluate((object) => {
      return object;
    });
    if (value === void 0) {
      throw new Error("Could not serialize referenced object");
    }
    return value;
  }
  asElement() {
    return null;
  }
  async dispose() {
    if (__classPrivateFieldGet6(this, _CDPJSHandle_disposed, "f")) {
      return;
    }
    __classPrivateFieldSet5(this, _CDPJSHandle_disposed, true, "f");
    await releaseObject(this.client, __classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f"));
  }
  toString() {
    if (!__classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f").objectId) {
      return "JSHandle:" + valueFromRemoteObject(__classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f"));
    }
    const type = __classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f").subtype || __classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f").type;
    return "JSHandle@" + type;
  }
  get id() {
    return __classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f").objectId;
  }
  remoteObject() {
    return __classPrivateFieldGet6(this, _CDPJSHandle_remoteObject, "f");
  }
};
_CDPJSHandle_disposed = /* @__PURE__ */ new WeakMap(), _CDPJSHandle_context = /* @__PURE__ */ new WeakMap(), _CDPJSHandle_remoteObject = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ElementHandle.js
var __classPrivateFieldSet6 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet7 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CDPElementHandle_instances;
var _CDPElementHandle_frame;
var _CDPElementHandle_frameManager_get;
var _CDPElementHandle_page_get;
var _CDPElementHandle_getOOPIFOffsets;
var _CDPElementHandle_getBoxModel;
var _CDPElementHandle_fromProtocolQuad;
var _CDPElementHandle_intersectQuadWithViewport;
var applyOffsetsToQuad = (quad, offsetX, offsetY) => {
  return quad.map((part) => {
    return { x: part.x + offsetX, y: part.y + offsetY };
  });
};
var CDPElementHandle = class extends ElementHandle {
  constructor(context, remoteObject, frame) {
    super(new CDPJSHandle(context, remoteObject));
    _CDPElementHandle_instances.add(this);
    _CDPElementHandle_frame.set(this, void 0);
    __classPrivateFieldSet6(this, _CDPElementHandle_frame, frame, "f");
  }
  executionContext() {
    return this.handle.executionContext();
  }
  get client() {
    return this.handle.client;
  }
  remoteObject() {
    return this.handle.remoteObject();
  }
  get frame() {
    return __classPrivateFieldGet7(this, _CDPElementHandle_frame, "f");
  }
  async $(selector) {
    return super.$(selector);
  }
  async $$(selector) {
    return super.$$(selector);
  }
  async waitForSelector(selector, options) {
    return await super.waitForSelector(selector, options);
  }
  async contentFrame() {
    const nodeInfo = await this.client.send("DOM.describeNode", {
      objectId: this.id
    });
    if (typeof nodeInfo.node.frameId !== "string") {
      return null;
    }
    return __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_frameManager_get).frame(nodeInfo.node.frameId);
  }
  async scrollIntoView() {
    await this.assertConnectedElement();
    try {
      await this.client.send("DOM.scrollIntoViewIfNeeded", {
        objectId: this.id
      });
    } catch (error) {
      debugError(error);
      await super.scrollIntoView();
    }
  }
  async clickablePoint(offset) {
    const [result, layoutMetrics] = await Promise.all([
      this.client.send("DOM.getContentQuads", {
        objectId: this.id
      }).catch(debugError),
      __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get)._client().send("Page.getLayoutMetrics")
    ]);
    if (!result || !result.quads.length) {
      throw new Error("Node is either not clickable or not an HTMLElement");
    }
    const { clientWidth, clientHeight } = layoutMetrics.cssLayoutViewport || layoutMetrics.layoutViewport;
    const { offsetX, offsetY } = await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet7(this, _CDPElementHandle_frame, "f"));
    const quads = result.quads.map((quad2) => {
      return __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, quad2);
    }).map((quad2) => {
      return applyOffsetsToQuad(quad2, offsetX, offsetY);
    }).map((quad2) => {
      return __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_intersectQuadWithViewport).call(this, quad2, clientWidth, clientHeight);
    }).filter((quad2) => {
      return computeQuadArea(quad2) > 1;
    });
    if (!quads.length) {
      throw new Error("Node is either not clickable or not an HTMLElement");
    }
    const quad = quads[0];
    if (offset) {
      let minX = Number.MAX_SAFE_INTEGER;
      let minY = Number.MAX_SAFE_INTEGER;
      for (const point of quad) {
        if (point.x < minX) {
          minX = point.x;
        }
        if (point.y < minY) {
          minY = point.y;
        }
      }
      if (minX !== Number.MAX_SAFE_INTEGER && minY !== Number.MAX_SAFE_INTEGER) {
        return {
          x: minX + offset.x,
          y: minY + offset.y
        };
      }
    }
    let x = 0;
    let y = 0;
    for (const point of quad) {
      x += point.x;
      y += point.y;
    }
    return {
      x: x / 4,
      y: y / 4
    };
  }
  async hover() {
    await this.scrollIntoViewIfNeeded();
    const { x, y } = await this.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.move(x, y);
  }
  async click(options = {}) {
    await this.scrollIntoViewIfNeeded();
    const { x, y } = await this.clickablePoint(options.offset);
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.click(x, y, options);
  }
  async drag(target) {
    assert(__classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).isDragInterceptionEnabled(), "Drag Interception is not enabled!");
    await this.scrollIntoViewIfNeeded();
    const start = await this.clickablePoint();
    return await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.drag(start, target);
  }
  async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
    await this.scrollIntoViewIfNeeded();
    const target = await this.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.dragEnter(target, data);
  }
  async dragOver(data = { items: [], dragOperationsMask: 1 }) {
    await this.scrollIntoViewIfNeeded();
    const target = await this.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.dragOver(target, data);
  }
  async drop(data = { items: [], dragOperationsMask: 1 }) {
    await this.scrollIntoViewIfNeeded();
    const destination = await this.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.drop(destination, data);
  }
  async dragAndDrop(target, options) {
    assert(__classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).isDragInterceptionEnabled(), "Drag Interception is not enabled!");
    await this.scrollIntoViewIfNeeded();
    const startPoint = await this.clickablePoint();
    const targetPoint = await target.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).mouse.dragAndDrop(startPoint, targetPoint, options);
  }
  async uploadFile(...filePaths) {
    const isMultiple = await this.evaluate((element) => {
      return element.multiple;
    });
    assert(filePaths.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
    let path;
    try {
      path = await import("./path-MFN3WKLV.js");
    } catch (error) {
      if (error instanceof TypeError) {
        throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
      }
      throw error;
    }
    const files = filePaths.map((filePath) => {
      if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {
        return filePath;
      } else {
        return path.resolve(filePath);
      }
    });
    const { node } = await this.client.send("DOM.describeNode", {
      objectId: this.id
    });
    const { backendNodeId } = node;
    if (files.length === 0) {
      await this.evaluate((element) => {
        element.files = new DataTransfer().files;
        element.dispatchEvent(new Event("input", { bubbles: true }));
        element.dispatchEvent(new Event("change", { bubbles: true }));
      });
    } else {
      await this.client.send("DOM.setFileInputFiles", {
        objectId: this.id,
        files,
        backendNodeId
      });
    }
  }
  async tap() {
    await this.scrollIntoViewIfNeeded();
    const { x, y } = await this.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchStart(x, y);
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchEnd();
  }
  async touchStart() {
    await this.scrollIntoViewIfNeeded();
    const { x, y } = await this.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchStart(x, y);
  }
  async touchMove() {
    await this.scrollIntoViewIfNeeded();
    const { x, y } = await this.clickablePoint();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchMove(x, y);
  }
  async touchEnd() {
    await this.scrollIntoViewIfNeeded();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).touchscreen.touchEnd();
  }
  async type(text, options) {
    await this.focus();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).keyboard.type(text, options);
  }
  async press(key, options) {
    await this.focus();
    await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).keyboard.press(key, options);
  }
  async boundingBox() {
    const result = await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getBoxModel).call(this);
    if (!result) {
      return null;
    }
    const { offsetX, offsetY } = await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet7(this, _CDPElementHandle_frame, "f"));
    const quad = result.model.border;
    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
    return { x: x + offsetX, y: y + offsetY, width, height };
  }
  async boxModel() {
    const result = await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getBoxModel).call(this);
    if (!result) {
      return null;
    }
    const { offsetX, offsetY } = await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_getOOPIFOffsets).call(this, __classPrivateFieldGet7(this, _CDPElementHandle_frame, "f"));
    const { content, padding, border, margin, width, height } = result.model;
    return {
      content: applyOffsetsToQuad(__classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, content), offsetX, offsetY),
      padding: applyOffsetsToQuad(__classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, padding), offsetX, offsetY),
      border: applyOffsetsToQuad(__classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, border), offsetX, offsetY),
      margin: applyOffsetsToQuad(__classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, margin), offsetX, offsetY),
      width,
      height
    };
  }
  async screenshot(options = {}) {
    let needsViewportReset = false;
    let boundingBox = await this.boundingBox();
    assert(boundingBox, "Node is either not visible or not an HTMLElement");
    const viewport = __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).viewport();
    if (viewport && (boundingBox.width > viewport.width || boundingBox.height > viewport.height)) {
      const newViewport = {
        width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
        height: Math.max(viewport.height, Math.ceil(boundingBox.height))
      };
      await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).setViewport(Object.assign({}, viewport, newViewport));
      needsViewportReset = true;
    }
    await this.scrollIntoViewIfNeeded();
    boundingBox = await this.boundingBox();
    assert(boundingBox, "Node is either not visible or not an HTMLElement");
    assert(boundingBox.width !== 0, "Node has 0 width.");
    assert(boundingBox.height !== 0, "Node has 0 height.");
    const layoutMetrics = await this.client.send("Page.getLayoutMetrics");
    const { pageX, pageY } = layoutMetrics.cssVisualViewport || layoutMetrics.layoutViewport;
    const clip = Object.assign({}, boundingBox);
    clip.x += pageX;
    clip.y += pageY;
    const imageData = await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).screenshot(Object.assign({}, {
      clip
    }, options));
    if (needsViewportReset && viewport) {
      await __classPrivateFieldGet7(this, _CDPElementHandle_instances, "a", _CDPElementHandle_page_get).setViewport(viewport);
    }
    return imageData;
  }
};
_CDPElementHandle_frame = /* @__PURE__ */ new WeakMap(), _CDPElementHandle_instances = /* @__PURE__ */ new WeakSet(), _CDPElementHandle_frameManager_get = function _CDPElementHandle_frameManager_get2() {
  return __classPrivateFieldGet7(this, _CDPElementHandle_frame, "f")._frameManager;
}, _CDPElementHandle_page_get = function _CDPElementHandle_page_get2() {
  return __classPrivateFieldGet7(this, _CDPElementHandle_frame, "f").page();
}, _CDPElementHandle_getOOPIFOffsets = async function _CDPElementHandle_getOOPIFOffsets2(frame) {
  let offsetX = 0;
  let offsetY = 0;
  let currentFrame = frame;
  while (currentFrame && currentFrame.parentFrame()) {
    const parent = currentFrame.parentFrame();
    if (!currentFrame.isOOPFrame() || !parent) {
      currentFrame = parent;
      continue;
    }
    const { backendNodeId } = await parent._client().send("DOM.getFrameOwner", {
      frameId: currentFrame._id
    });
    const result = await parent._client().send("DOM.getBoxModel", {
      backendNodeId
    });
    if (!result) {
      break;
    }
    const contentBoxQuad = result.model.content;
    const topLeftCorner = __classPrivateFieldGet7(this, _CDPElementHandle_instances, "m", _CDPElementHandle_fromProtocolQuad).call(this, contentBoxQuad)[0];
    offsetX += topLeftCorner.x;
    offsetY += topLeftCorner.y;
    currentFrame = parent;
  }
  return { offsetX, offsetY };
}, _CDPElementHandle_getBoxModel = function _CDPElementHandle_getBoxModel2() {
  const params = {
    objectId: this.id
  };
  return this.client.send("DOM.getBoxModel", params).catch((error) => {
    return debugError(error);
  });
}, _CDPElementHandle_fromProtocolQuad = function _CDPElementHandle_fromProtocolQuad2(quad) {
  return [
    { x: quad[0], y: quad[1] },
    { x: quad[2], y: quad[3] },
    { x: quad[4], y: quad[5] },
    { x: quad[6], y: quad[7] }
  ];
}, _CDPElementHandle_intersectQuadWithViewport = function _CDPElementHandle_intersectQuadWithViewport2(quad, width, height) {
  return quad.map((point) => {
    return {
      x: Math.min(Math.max(point.x, 0), width),
      y: Math.min(Math.max(point.y, 0), height)
    };
  });
};
function computeQuadArea(quad) {
  let area = 0;
  for (let i = 0; i < quad.length; ++i) {
    const p1 = quad[i];
    const p2 = quad[(i + 1) % quad.length];
    area += (p1.x * p2.y - p2.x * p1.y) / 2;
  }
  return Math.abs(area);
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js
var __classPrivateFieldSet7 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet8 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PuppeteerURL_functionName;
var _PuppeteerURL_siteString;
var debugError = debug("puppeteer:error");
function createEvaluationError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const messageHeight = message.split("\n").length;
  const error = new Error(message);
  error.name = name;
  const stackLines = error.stack.split("\n");
  const messageLines = stackLines.splice(0, messageHeight);
  stackLines.shift();
  if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
    for (const frame of details.stackTrace.callFrames.reverse()) {
      if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
        const url = PuppeteerURL.parse(frame.url);
        stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
      } else {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
      }
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
function createClientError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const messageHeight = message.split("\n").length;
  const error = new Error(message);
  error.name = name;
  const stackLines = [];
  const messageLines = error.stack.split("\n").splice(0, messageHeight);
  if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
    for (const frame of details.stackTrace.callFrames.reverse()) {
      stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
var getErrorDetails = (details) => {
  var _a2, _b, _c, _d, _e, _f;
  let name = "";
  let message;
  const lines = (_c = (_b = (_a2 = details.exception) == null ? void 0 : _a2.description) == null ? void 0 : _b.split("\n    at ")) != null ? _c : [];
  const size = Math.min((_e = (_d = details.stackTrace) == null ? void 0 : _d.callFrames.length) != null ? _e : 0, lines.length - 1);
  lines.splice(-size, size);
  if ((_f = details.exception) == null ? void 0 : _f.className) {
    name = details.exception.className;
  }
  message = lines.join("\n");
  if (name && message.startsWith(`${name}: `)) {
    message = message.slice(name.length + 2);
  }
  return { message, name };
};
var SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
var PuppeteerURL = class {
  constructor() {
    _PuppeteerURL_functionName.set(this, void 0);
    _PuppeteerURL_siteString.set(this, void 0);
  }
  static fromCallSite(functionName, site) {
    const url = new PuppeteerURL();
    __classPrivateFieldSet7(url, _PuppeteerURL_functionName, functionName, "f");
    __classPrivateFieldSet7(url, _PuppeteerURL_siteString, site.toString(), "f");
    return url;
  }
  get functionName() {
    return __classPrivateFieldGet8(this, _PuppeteerURL_functionName, "f");
  }
  get siteString() {
    return __classPrivateFieldGet8(this, _PuppeteerURL_siteString, "f");
  }
  toString() {
    return `pptr:${[
      __classPrivateFieldGet8(this, _PuppeteerURL_functionName, "f"),
      encodeURIComponent(__classPrivateFieldGet8(this, _PuppeteerURL_siteString, "f"))
    ].join(";")}`;
  }
};
_PuppeteerURL_functionName = /* @__PURE__ */ new WeakMap(), _PuppeteerURL_siteString = /* @__PURE__ */ new WeakMap();
PuppeteerURL.INTERNAL_URL = "pptr:internal";
PuppeteerURL.parse = (url) => {
  url = url.slice("pptr:".length);
  const [functionName = "", siteString = ""] = url.split(";");
  const puppeteerUrl = new PuppeteerURL();
  __classPrivateFieldSet7(puppeteerUrl, _PuppeteerURL_functionName, functionName, "f");
  __classPrivateFieldSet7(puppeteerUrl, _PuppeteerURL_siteString, decodeURIComponent(siteString), "f");
  return puppeteerUrl;
};
PuppeteerURL.isPuppeteerURL = (url) => {
  return url.startsWith("pptr:");
};
var withSourcePuppeteerURLIfNone = (functionName, object) => {
  if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
    return object;
  }
  const original = Error.prepareStackTrace;
  Error.prepareStackTrace = (_, stack) => {
    return stack[2];
  };
  const site = new Error().stack;
  Error.prepareStackTrace = original;
  return Object.assign(object, {
    [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
  });
};
var getSourcePuppeteerURLIfAvailable = (object) => {
  if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
    return object[SOURCE_URL];
  }
  return void 0;
};
function valueFromRemoteObject(remoteObject) {
  assert(!remoteObject.objectId, "Cannot extract value when objectId is given");
  if (remoteObject.unserializableValue) {
    if (remoteObject.type === "bigint") {
      return BigInt(remoteObject.unserializableValue.replace("n", ""));
    }
    switch (remoteObject.unserializableValue) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
    }
  }
  return remoteObject.value;
}
async function releaseObject(client, remoteObject) {
  if (!remoteObject.objectId) {
    return;
  }
  await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
    debugError(error);
  });
}
function addEventListener(emitter, eventName, handler) {
  emitter.on(eventName, handler);
  return { emitter, eventName, handler };
}
function removeEventListeners(listeners) {
  for (const listener of listeners) {
    listener.emitter.removeListener(listener.eventName, listener.handler);
  }
  listeners.length = 0;
}
var isString = (obj) => {
  return typeof obj === "string" || obj instanceof String;
};
var isNumber = (obj) => {
  return typeof obj === "number" || obj instanceof Number;
};
var isPlainObject = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Object;
};
var isRegExp = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === RegExp;
};
var isDate = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Date;
};
async function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
  const deferred = Deferred.create({
    message: `Timeout exceeded while waiting for event ${String(eventName)}`,
    timeout
  });
  const listener = addEventListener(emitter, eventName, async (event) => {
    if (await predicate(event)) {
      deferred.resolve(event);
    }
  });
  return Deferred.race([deferred, abortPromise]).then((r) => {
    removeEventListeners([listener]);
    if (isErrorLike(r)) {
      throw r;
    }
    return r;
  }, (error) => {
    removeEventListeners([listener]);
    throw error;
  });
}
function createJSHandle(context, remoteObject) {
  if (remoteObject.subtype === "node" && context._world) {
    return new CDPElementHandle(context, remoteObject, context._world.frame());
  }
  return new CDPJSHandle(context, remoteObject);
}
function evaluationString(fun, ...args) {
  if (isString(fun)) {
    assert(args.length === 0, "Cannot evaluate a string with arguments");
    return fun;
  }
  function serializeArgument(arg) {
    if (Object.is(arg, void 0)) {
      return "undefined";
    }
    return JSON.stringify(arg);
  }
  return `(${fun})(${args.map(serializeArgument).join(",")})`;
}
function addPageBinding(type, name) {
  const callCDP = globalThis[name];
  Object.assign(globalThis, {
    [name](...args) {
      var _a2, _b, _c;
      const callPuppeteer = globalThis[name];
      (_a2 = callPuppeteer.args) != null ? _a2 : callPuppeteer.args = /* @__PURE__ */ new Map();
      (_b = callPuppeteer.callbacks) != null ? _b : callPuppeteer.callbacks = /* @__PURE__ */ new Map();
      const seq = ((_c = callPuppeteer.lastSeq) != null ? _c : 0) + 1;
      callPuppeteer.lastSeq = seq;
      callPuppeteer.args.set(seq, args);
      callCDP(JSON.stringify({
        type,
        name,
        seq,
        args,
        isTrivial: !args.some((value) => {
          return value instanceof Node;
        })
      }));
      return new Promise((resolve, reject) => {
        callPuppeteer.callbacks.set(seq, {
          resolve(value) {
            callPuppeteer.args.delete(seq);
            resolve(value);
          },
          reject(value) {
            callPuppeteer.args.delete(seq);
            reject(value);
          }
        });
      });
    }
  });
}
function pageBindingInitString(type, name) {
  return evaluationString(addPageBinding, type, name);
}
async function waitWithTimeout(promise, taskName, timeout) {
  const deferred = Deferred.create({
    message: `waiting for ${taskName} failed: timeout ${timeout}ms exceeded`,
    timeout
  });
  return await Deferred.race([promise, deferred]).finally(() => {
    deferred.reject(new Error("Cleared"));
  });
}
var fs = null;
async function importFSPromises() {
  if (!fs) {
    try {
      fs = await import("./promises-JOE7E3RY.js");
    } catch (error) {
      if (error instanceof TypeError) {
        throw new Error("Cannot write to a path outside of a Node-like environment.");
      }
      throw error;
    }
  }
  return fs;
}
async function getReadableAsBuffer(readable, path) {
  const buffers = [];
  if (path) {
    const fs2 = await importFSPromises();
    const fileHandle = await fs2.open(path, "w+");
    try {
      for await (const chunk of readable) {
        buffers.push(chunk);
        await fileHandle.writeFile(chunk);
      }
    } finally {
      await fileHandle.close();
    }
  } else {
    for await (const chunk of readable) {
      buffers.push(chunk);
    }
  }
  try {
    return Buffer.concat(buffers);
  } catch (error) {
    return null;
  }
}
async function getReadableFromProtocolStream(client, handle) {
  if (!isNode) {
    throw new Error("Cannot create a stream outside of Node.js environment.");
  }
  const { Readable } = await import("./stream-WNBH26D6.js");
  let eof = false;
  return new Readable({
    async read(size) {
      if (eof) {
        return;
      }
      try {
        const response = await client.send("IO.read", { handle, size });
        this.push(response.data, response.base64Encoded ? "base64" : void 0);
        if (response.eof) {
          eof = true;
          await client.send("IO.close", { handle });
          this.push(null);
        }
      } catch (error) {
        if (isErrorLike(error)) {
          this.destroy(error);
          return;
        }
        throw error;
      }
    }
  });
}
async function setPageContent(page, content) {
  return page.evaluate((html) => {
    document.open();
    document.write(html);
    document.close();
  }, content);
}
function getPageContent() {
  let content = "";
  for (const node of document.childNodes) {
    switch (node) {
      case document.documentElement:
        content += document.documentElement.outerHTML;
        break;
      default:
        content += new XMLSerializer().serializeToString(node);
        break;
    }
  }
  return content;
}

// node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js
var __classPrivateFieldGet9 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ElementHandle_instances;
var _ElementHandle_checkVisibility;
var _ElementHandle_asSVGElementHandle;
var _ElementHandle_getOwnerSVGElement;
var ElementHandle = class extends JSHandle {
  constructor(handle) {
    super();
    _ElementHandle_instances.add(this);
    this.handle = handle;
  }
  get id() {
    return this.handle.id;
  }
  get disposed() {
    return this.handle.disposed;
  }
  async getProperty(propertyName) {
    return this.handle.getProperty(propertyName);
  }
  async getProperties() {
    return this.handle.getProperties();
  }
  async evaluate(pageFunction, ...args) {
    return this.handle.evaluate(pageFunction, ...args);
  }
  evaluateHandle(pageFunction, ...args) {
    return this.handle.evaluateHandle(pageFunction, ...args);
  }
  async jsonValue() {
    return this.handle.jsonValue();
  }
  toString() {
    return this.handle.toString();
  }
  async dispose() {
    return await this.handle.dispose();
  }
  asElement() {
    return this;
  }
  executionContext() {
    throw new Error("Not implemented");
  }
  get client() {
    throw new Error("Not implemented");
  }
  get frame() {
    throw new Error("Not implemented");
  }
  async $(selector) {
    const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
    return await QueryHandler2.queryOne(this, updatedSelector);
  }
  async $$(selector) {
    const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
    return AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
  }
  async $eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
    const elementHandle = await this.$(selector);
    if (!elementHandle) {
      throw new Error(`Error: failed to find element matching selector "${selector}"`);
    }
    const result = await elementHandle.evaluate(pageFunction, ...args);
    await elementHandle.dispose();
    return result;
  }
  async $$eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
    const results = await this.$$(selector);
    const elements = await this.evaluateHandle((_, ...elements2) => {
      return elements2;
    }, ...results);
    const [result] = await Promise.all([
      elements.evaluate(pageFunction, ...args),
      ...results.map((results2) => {
        return results2.dispose();
      })
    ]);
    await elements.dispose();
    return result;
  }
  async $x(expression) {
    if (expression.startsWith("//")) {
      expression = `.${expression}`;
    }
    return this.$$(`xpath/${expression}`);
  }
  async waitForSelector(selector, options = {}) {
    const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
    return await QueryHandler2.waitFor(this, updatedSelector, options);
  }
  async isVisible() {
    return __classPrivateFieldGet9(this, _ElementHandle_instances, "m", _ElementHandle_checkVisibility).call(this, true);
  }
  async isHidden() {
    return __classPrivateFieldGet9(this, _ElementHandle_instances, "m", _ElementHandle_checkVisibility).call(this, false);
  }
  async waitForXPath(xpath, options = {}) {
    if (xpath.startsWith("//")) {
      xpath = `.${xpath}`;
    }
    return this.waitForSelector(`xpath/${xpath}`, options);
  }
  async toElement(tagName) {
    const isMatchingTagName = await this.evaluate((node, tagName2) => {
      return node.nodeName === tagName2.toUpperCase();
    }, tagName);
    if (!isMatchingTagName) {
      throw new Error(`Element is not a(n) \`${tagName}\` element`);
    }
    return this;
  }
  async contentFrame() {
    throw new Error("Not implemented");
  }
  async clickablePoint() {
    throw new Error("Not implemented");
  }
  async hover() {
    throw new Error("Not implemented");
  }
  async click() {
    throw new Error("Not implemented");
  }
  async drag() {
    throw new Error("Not implemented");
  }
  async dragEnter() {
    throw new Error("Not implemented");
  }
  async dragOver() {
    throw new Error("Not implemented");
  }
  async drop() {
    throw new Error("Not implemented");
  }
  async dragAndDrop() {
    throw new Error("Not implemented");
  }
  async select(...values) {
    for (const value of values) {
      assert(isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
    }
    return this.evaluate((element, vals) => {
      const values2 = new Set(vals);
      if (!(element instanceof HTMLSelectElement)) {
        throw new Error("Element is not a <select> element.");
      }
      const selectedValues = /* @__PURE__ */ new Set();
      if (!element.multiple) {
        for (const option of element.options) {
          option.selected = false;
        }
        for (const option of element.options) {
          if (values2.has(option.value)) {
            option.selected = true;
            selectedValues.add(option.value);
            break;
          }
        }
      } else {
        for (const option of element.options) {
          option.selected = values2.has(option.value);
          if (option.selected) {
            selectedValues.add(option.value);
          }
        }
      }
      element.dispatchEvent(new Event("input", { bubbles: true }));
      element.dispatchEvent(new Event("change", { bubbles: true }));
      return [...selectedValues.values()];
    }, values);
  }
  async uploadFile() {
    throw new Error("Not implemented");
  }
  async tap() {
    throw new Error("Not implemented");
  }
  async touchStart() {
    throw new Error("Not implemented");
  }
  async touchMove() {
    throw new Error("Not implemented");
  }
  async touchEnd() {
    throw new Error("Not implemented");
  }
  async focus() {
    await this.evaluate((element) => {
      if (!(element instanceof HTMLElement)) {
        throw new Error("Cannot focus non-HTMLElement");
      }
      return element.focus();
    });
  }
  async type() {
    throw new Error("Not implemented");
  }
  async press() {
    throw new Error("Not implemented");
  }
  async boundingBox() {
    throw new Error("Not implemented");
  }
  async boxModel() {
    throw new Error("Not implemented");
  }
  async screenshot() {
    throw new Error("Not implemented");
  }
  async assertConnectedElement() {
    const error = await this.evaluate(async (element) => {
      if (!element.isConnected) {
        return "Node is detached from document";
      }
      if (element.nodeType !== Node.ELEMENT_NODE) {
        return "Node is not of type HTMLElement";
      }
      return;
    });
    if (error) {
      throw new Error(error);
    }
  }
  async scrollIntoViewIfNeeded() {
    if (await this.isIntersectingViewport({
      threshold: 1
    })) {
      return;
    }
    await this.scrollIntoView();
  }
  async isIntersectingViewport(options) {
    await this.assertConnectedElement();
    const { threshold = 0 } = options != null ? options : {};
    const svgHandle = await __classPrivateFieldGet9(this, _ElementHandle_instances, "m", _ElementHandle_asSVGElementHandle).call(this, this);
    const intersectionTarget = svgHandle ? await __classPrivateFieldGet9(this, _ElementHandle_instances, "m", _ElementHandle_getOwnerSVGElement).call(this, svgHandle) : this;
    try {
      return await intersectionTarget.evaluate(async (element, threshold2) => {
        const visibleRatio = await new Promise((resolve) => {
          const observer = new IntersectionObserver((entries) => {
            resolve(entries[0].intersectionRatio);
            observer.disconnect();
          });
          observer.observe(element);
        });
        return threshold2 === 1 ? visibleRatio === 1 : visibleRatio > threshold2;
      }, threshold);
    } finally {
      if (intersectionTarget !== this) {
        await intersectionTarget.dispose();
      }
    }
  }
  async scrollIntoView() {
    await this.assertConnectedElement();
    await this.evaluate(async (element) => {
      element.scrollIntoView({
        block: "center",
        inline: "center",
        behavior: "instant"
      });
    });
  }
  assertElementHasWorld() {
    assert(this.executionContext()._world);
  }
};
_ElementHandle_instances = /* @__PURE__ */ new WeakSet(), _ElementHandle_checkVisibility = async function _ElementHandle_checkVisibility2(visibility) {
  const element = await this.frame.isolatedRealm().adoptHandle(this);
  try {
    return await this.frame.isolatedRealm().evaluate(async (PuppeteerUtil, element2, visibility2) => {
      return Boolean(PuppeteerUtil.checkVisibility(element2, visibility2));
    }, LazyArg.create((context) => {
      return context.puppeteerUtil;
    }), element, visibility);
  } finally {
    await element.dispose();
  }
}, _ElementHandle_asSVGElementHandle = async function _ElementHandle_asSVGElementHandle2(handle) {
  if (await handle.evaluate((element) => {
    return element instanceof SVGElement;
  })) {
    return handle;
  } else {
    return null;
  }
}, _ElementHandle_getOwnerSVGElement = async function _ElementHandle_getOwnerSVGElement2(handle) {
  return await handle.evaluateHandle((element) => {
    if (element instanceof SVGSVGElement) {
      return element;
    }
    return element.ownerSVGElement;
  });
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js
var DEFAULT_BATCH_SIZE = 20;
async function* fastTransposeIteratorHandle(iterator, size) {
  const array = await iterator.evaluateHandle(async (iterator2, size2) => {
    const results = [];
    while (results.length < size2) {
      const result = await iterator2.next();
      if (result.done) {
        break;
      }
      results.push(result.value);
    }
    return results;
  }, size);
  const properties = await array.getProperties();
  await array.dispose();
  yield* properties.values();
  return properties.size === 0;
}
async function* transposeIteratorHandle(iterator) {
  let size = DEFAULT_BATCH_SIZE;
  try {
    while (!(yield* fastTransposeIteratorHandle(iterator, size))) {
      size <<= 1;
    }
  } finally {
    await iterator.dispose();
  }
}
async function* transposeIterableHandle(handle) {
  yield* transposeIteratorHandle(await handle.evaluateHandle((iterable) => {
    return async function* () {
      yield* iterable;
    }();
  }));
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js
var QueryHandler = class {
  static get _querySelector() {
    if (this.querySelector) {
      return this.querySelector;
    }
    if (!this.querySelectorAll) {
      throw new Error("Cannot create default `querySelector`.");
    }
    return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
      const querySelectorAll = PLACEHOLDER("querySelectorAll");
      const results = querySelectorAll(node, selector, PuppeteerUtil);
      for await (const result of results) {
        return result;
      }
      return null;
    }, {
      querySelectorAll: stringifyFunction(this.querySelectorAll)
    });
  }
  static get _querySelectorAll() {
    if (this.querySelectorAll) {
      return this.querySelectorAll;
    }
    if (!this.querySelector) {
      throw new Error("Cannot create default `querySelectorAll`.");
    }
    return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
      const querySelector = PLACEHOLDER("querySelector");
      const result = await querySelector(node, selector, PuppeteerUtil);
      if (result) {
        yield result;
      }
    }, {
      querySelector: stringifyFunction(this.querySelector)
    });
  }
  static async *queryAll(element, selector) {
    element.assertElementHasWorld();
    const handle = await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context) => {
      return context.puppeteerUtil;
    }));
    yield* transposeIterableHandle(handle);
  }
  static async queryOne(element, selector) {
    element.assertElementHasWorld();
    const result = await element.evaluateHandle(this._querySelector, selector, LazyArg.create((context) => {
      return context.puppeteerUtil;
    }));
    if (!(result instanceof ElementHandle)) {
      await result.dispose();
      return null;
    }
    return result;
  }
  static async waitFor(elementOrFrame, selector, options) {
    let frame;
    let element;
    if (!(elementOrFrame instanceof ElementHandle)) {
      frame = elementOrFrame;
    } else {
      frame = elementOrFrame.frame;
      element = await frame.isolatedRealm().adoptHandle(elementOrFrame);
    }
    const { visible = false, hidden = false, timeout, signal } = options;
    try {
      signal == null ? void 0 : signal.throwIfAborted();
      const handle = await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
        const querySelector = PuppeteerUtil.createFunction(query);
        const node = await querySelector(root != null ? root : document, selector2, PuppeteerUtil);
        return PuppeteerUtil.checkVisibility(node, visible2);
      }, {
        polling: visible || hidden ? "raf" : "mutation",
        root: element,
        timeout,
        signal
      }, LazyArg.create((context) => {
        return context.puppeteerUtil;
      }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : void 0);
      if (signal == null ? void 0 : signal.aborted) {
        await handle.dispose();
        throw signal.reason;
      }
      if (!(handle instanceof ElementHandle)) {
        await handle.dispose();
        return null;
      }
      return frame.mainRealm().transferHandle(handle);
    } catch (error) {
      if (!isErrorLike(error)) {
        throw error;
      }
      if (error.name === "AbortError") {
        throw error;
      }
      error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
      throw error;
    } finally {
      if (element) {
        await element.dispose();
      }
    }
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js
var HTTPResponse = class {
  constructor() {
  }
  _resolveBody(_err) {
    throw new Error("Not implemented");
  }
  remoteAddress() {
    throw new Error("Not implemented");
  }
  url() {
    throw new Error("Not implemented");
  }
  ok() {
    const status = this.status();
    return status === 0 || status >= 200 && status <= 299;
  }
  status() {
    throw new Error("Not implemented");
  }
  statusText() {
    throw new Error("Not implemented");
  }
  headers() {
    throw new Error("Not implemented");
  }
  securityDetails() {
    throw new Error("Not implemented");
  }
  timing() {
    throw new Error("Not implemented");
  }
  buffer() {
    throw new Error("Not implemented");
  }
  async text() {
    const content = await this.buffer();
    return content.toString("utf8");
  }
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
  request() {
    throw new Error("Not implemented");
  }
  fromCache() {
    throw new Error("Not implemented");
  }
  fromServiceWorker() {
    throw new Error("Not implemented");
  }
  frame() {
    throw new Error("Not implemented");
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js
var __classPrivateFieldSet8 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet10 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SecurityDetails_subjectName;
var _SecurityDetails_issuer;
var _SecurityDetails_validFrom;
var _SecurityDetails_validTo;
var _SecurityDetails_protocol;
var _SecurityDetails_sanList;
var SecurityDetails = class {
  constructor(securityPayload) {
    _SecurityDetails_subjectName.set(this, void 0);
    _SecurityDetails_issuer.set(this, void 0);
    _SecurityDetails_validFrom.set(this, void 0);
    _SecurityDetails_validTo.set(this, void 0);
    _SecurityDetails_protocol.set(this, void 0);
    _SecurityDetails_sanList.set(this, void 0);
    __classPrivateFieldSet8(this, _SecurityDetails_subjectName, securityPayload.subjectName, "f");
    __classPrivateFieldSet8(this, _SecurityDetails_issuer, securityPayload.issuer, "f");
    __classPrivateFieldSet8(this, _SecurityDetails_validFrom, securityPayload.validFrom, "f");
    __classPrivateFieldSet8(this, _SecurityDetails_validTo, securityPayload.validTo, "f");
    __classPrivateFieldSet8(this, _SecurityDetails_protocol, securityPayload.protocol, "f");
    __classPrivateFieldSet8(this, _SecurityDetails_sanList, securityPayload.sanList, "f");
  }
  issuer() {
    return __classPrivateFieldGet10(this, _SecurityDetails_issuer, "f");
  }
  validFrom() {
    return __classPrivateFieldGet10(this, _SecurityDetails_validFrom, "f");
  }
  validTo() {
    return __classPrivateFieldGet10(this, _SecurityDetails_validTo, "f");
  }
  protocol() {
    return __classPrivateFieldGet10(this, _SecurityDetails_protocol, "f");
  }
  subjectName() {
    return __classPrivateFieldGet10(this, _SecurityDetails_subjectName, "f");
  }
  subjectAlternativeNames() {
    return __classPrivateFieldGet10(this, _SecurityDetails_sanList, "f");
  }
};
_SecurityDetails_subjectName = /* @__PURE__ */ new WeakMap(), _SecurityDetails_issuer = /* @__PURE__ */ new WeakMap(), _SecurityDetails_validFrom = /* @__PURE__ */ new WeakMap(), _SecurityDetails_validTo = /* @__PURE__ */ new WeakMap(), _SecurityDetails_protocol = /* @__PURE__ */ new WeakMap(), _SecurityDetails_sanList = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkEventManager.js
var __classPrivateFieldGet11 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NetworkEventManager_requestWillBeSentMap;
var _NetworkEventManager_requestPausedMap;
var _NetworkEventManager_httpRequestsMap;
var _NetworkEventManager_responseReceivedExtraInfoMap;
var _NetworkEventManager_queuedRedirectInfoMap;
var _NetworkEventManager_queuedEventGroupMap;
var NetworkEventManager = class {
  constructor() {
    _NetworkEventManager_requestWillBeSentMap.set(this, /* @__PURE__ */ new Map());
    _NetworkEventManager_requestPausedMap.set(this, /* @__PURE__ */ new Map());
    _NetworkEventManager_httpRequestsMap.set(this, /* @__PURE__ */ new Map());
    _NetworkEventManager_responseReceivedExtraInfoMap.set(this, /* @__PURE__ */ new Map());
    _NetworkEventManager_queuedRedirectInfoMap.set(this, /* @__PURE__ */ new Map());
    _NetworkEventManager_queuedEventGroupMap.set(this, /* @__PURE__ */ new Map());
  }
  forget(networkRequestId) {
    __classPrivateFieldGet11(this, _NetworkEventManager_requestWillBeSentMap, "f").delete(networkRequestId);
    __classPrivateFieldGet11(this, _NetworkEventManager_requestPausedMap, "f").delete(networkRequestId);
    __classPrivateFieldGet11(this, _NetworkEventManager_queuedEventGroupMap, "f").delete(networkRequestId);
    __classPrivateFieldGet11(this, _NetworkEventManager_queuedRedirectInfoMap, "f").delete(networkRequestId);
    __classPrivateFieldGet11(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").delete(networkRequestId);
  }
  responseExtraInfo(networkRequestId) {
    if (!__classPrivateFieldGet11(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").has(networkRequestId)) {
      __classPrivateFieldGet11(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").set(networkRequestId, []);
    }
    return __classPrivateFieldGet11(this, _NetworkEventManager_responseReceivedExtraInfoMap, "f").get(networkRequestId);
  }
  queuedRedirectInfo(fetchRequestId) {
    if (!__classPrivateFieldGet11(this, _NetworkEventManager_queuedRedirectInfoMap, "f").has(fetchRequestId)) {
      __classPrivateFieldGet11(this, _NetworkEventManager_queuedRedirectInfoMap, "f").set(fetchRequestId, []);
    }
    return __classPrivateFieldGet11(this, _NetworkEventManager_queuedRedirectInfoMap, "f").get(fetchRequestId);
  }
  queueRedirectInfo(fetchRequestId, redirectInfo) {
    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
  }
  takeQueuedRedirectInfo(fetchRequestId) {
    return this.queuedRedirectInfo(fetchRequestId).shift();
  }
  inFlightRequestsCount() {
    let inFlightRequestCounter = 0;
    for (const request of __classPrivateFieldGet11(this, _NetworkEventManager_httpRequestsMap, "f").values()) {
      if (!request.response()) {
        inFlightRequestCounter++;
      }
    }
    return inFlightRequestCounter;
  }
  storeRequestWillBeSent(networkRequestId, event) {
    __classPrivateFieldGet11(this, _NetworkEventManager_requestWillBeSentMap, "f").set(networkRequestId, event);
  }
  getRequestWillBeSent(networkRequestId) {
    return __classPrivateFieldGet11(this, _NetworkEventManager_requestWillBeSentMap, "f").get(networkRequestId);
  }
  forgetRequestWillBeSent(networkRequestId) {
    __classPrivateFieldGet11(this, _NetworkEventManager_requestWillBeSentMap, "f").delete(networkRequestId);
  }
  getRequestPaused(networkRequestId) {
    return __classPrivateFieldGet11(this, _NetworkEventManager_requestPausedMap, "f").get(networkRequestId);
  }
  forgetRequestPaused(networkRequestId) {
    __classPrivateFieldGet11(this, _NetworkEventManager_requestPausedMap, "f").delete(networkRequestId);
  }
  storeRequestPaused(networkRequestId, event) {
    __classPrivateFieldGet11(this, _NetworkEventManager_requestPausedMap, "f").set(networkRequestId, event);
  }
  getRequest(networkRequestId) {
    return __classPrivateFieldGet11(this, _NetworkEventManager_httpRequestsMap, "f").get(networkRequestId);
  }
  storeRequest(networkRequestId, request) {
    __classPrivateFieldGet11(this, _NetworkEventManager_httpRequestsMap, "f").set(networkRequestId, request);
  }
  forgetRequest(networkRequestId) {
    __classPrivateFieldGet11(this, _NetworkEventManager_httpRequestsMap, "f").delete(networkRequestId);
  }
  getQueuedEventGroup(networkRequestId) {
    return __classPrivateFieldGet11(this, _NetworkEventManager_queuedEventGroupMap, "f").get(networkRequestId);
  }
  queueEventGroup(networkRequestId, event) {
    __classPrivateFieldGet11(this, _NetworkEventManager_queuedEventGroupMap, "f").set(networkRequestId, event);
  }
  forgetQueuedEventGroup(networkRequestId) {
    __classPrivateFieldGet11(this, _NetworkEventManager_queuedEventGroupMap, "f").delete(networkRequestId);
  }
};
_NetworkEventManager_requestWillBeSentMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_requestPausedMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_httpRequestsMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_responseReceivedExtraInfoMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_queuedRedirectInfoMap = /* @__PURE__ */ new WeakMap(), _NetworkEventManager_queuedEventGroupMap = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPRequest.js
var __classPrivateFieldGet12 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet9 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _HTTPRequest_instances;
var _HTTPRequest_client;
var _HTTPRequest_isNavigationRequest;
var _HTTPRequest_allowInterception;
var _HTTPRequest_interceptionHandled;
var _HTTPRequest_url;
var _HTTPRequest_resourceType;
var _HTTPRequest_method;
var _HTTPRequest_postData;
var _HTTPRequest_headers;
var _HTTPRequest_frame;
var _HTTPRequest_continueRequestOverrides;
var _HTTPRequest_responseForRequest;
var _HTTPRequest_abortErrorReason;
var _HTTPRequest_interceptResolutionState;
var _HTTPRequest_interceptHandlers;
var _HTTPRequest_initiator;
var _HTTPRequest_continue;
var _HTTPRequest_respond;
var _HTTPRequest_abort;
var HTTPRequest2 = class extends HTTPRequest {
  get client() {
    return __classPrivateFieldGet12(this, _HTTPRequest_client, "f");
  }
  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
    super();
    _HTTPRequest_instances.add(this);
    this._failureText = null;
    this._response = null;
    this._fromMemoryCache = false;
    _HTTPRequest_client.set(this, void 0);
    _HTTPRequest_isNavigationRequest.set(this, void 0);
    _HTTPRequest_allowInterception.set(this, void 0);
    _HTTPRequest_interceptionHandled.set(this, false);
    _HTTPRequest_url.set(this, void 0);
    _HTTPRequest_resourceType.set(this, void 0);
    _HTTPRequest_method.set(this, void 0);
    _HTTPRequest_postData.set(this, void 0);
    _HTTPRequest_headers.set(this, {});
    _HTTPRequest_frame.set(this, void 0);
    _HTTPRequest_continueRequestOverrides.set(this, void 0);
    _HTTPRequest_responseForRequest.set(this, null);
    _HTTPRequest_abortErrorReason.set(this, null);
    _HTTPRequest_interceptResolutionState.set(this, {
      action: InterceptResolutionAction.None
    });
    _HTTPRequest_interceptHandlers.set(this, void 0);
    _HTTPRequest_initiator.set(this, void 0);
    __classPrivateFieldSet9(this, _HTTPRequest_client, client, "f");
    this._requestId = data.requestId;
    __classPrivateFieldSet9(this, _HTTPRequest_isNavigationRequest, data.requestId === data.loaderId && data.type === "Document", "f");
    this._interceptionId = interceptionId;
    __classPrivateFieldSet9(this, _HTTPRequest_allowInterception, allowInterception, "f");
    __classPrivateFieldSet9(this, _HTTPRequest_url, data.request.url, "f");
    __classPrivateFieldSet9(this, _HTTPRequest_resourceType, (data.type || "other").toLowerCase(), "f");
    __classPrivateFieldSet9(this, _HTTPRequest_method, data.request.method, "f");
    __classPrivateFieldSet9(this, _HTTPRequest_postData, data.request.postData, "f");
    __classPrivateFieldSet9(this, _HTTPRequest_frame, frame, "f");
    this._redirectChain = redirectChain;
    __classPrivateFieldSet9(this, _HTTPRequest_continueRequestOverrides, {}, "f");
    __classPrivateFieldSet9(this, _HTTPRequest_interceptHandlers, [], "f");
    __classPrivateFieldSet9(this, _HTTPRequest_initiator, data.initiator, "f");
    for (const [key, value] of Object.entries(data.request.headers)) {
      __classPrivateFieldGet12(this, _HTTPRequest_headers, "f")[key.toLowerCase()] = value;
    }
  }
  url() {
    return __classPrivateFieldGet12(this, _HTTPRequest_url, "f");
  }
  continueRequestOverrides() {
    assert(__classPrivateFieldGet12(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
    return __classPrivateFieldGet12(this, _HTTPRequest_continueRequestOverrides, "f");
  }
  responseForRequest() {
    assert(__classPrivateFieldGet12(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
    return __classPrivateFieldGet12(this, _HTTPRequest_responseForRequest, "f");
  }
  abortErrorReason() {
    assert(__classPrivateFieldGet12(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
    return __classPrivateFieldGet12(this, _HTTPRequest_abortErrorReason, "f");
  }
  interceptResolutionState() {
    if (!__classPrivateFieldGet12(this, _HTTPRequest_allowInterception, "f")) {
      return { action: InterceptResolutionAction.Disabled };
    }
    if (__classPrivateFieldGet12(this, _HTTPRequest_interceptionHandled, "f")) {
      return { action: InterceptResolutionAction.AlreadyHandled };
    }
    return { ...__classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f") };
  }
  isInterceptResolutionHandled() {
    return __classPrivateFieldGet12(this, _HTTPRequest_interceptionHandled, "f");
  }
  enqueueInterceptAction(pendingHandler) {
    __classPrivateFieldGet12(this, _HTTPRequest_interceptHandlers, "f").push(pendingHandler);
  }
  async finalizeInterceptions() {
    await __classPrivateFieldGet12(this, _HTTPRequest_interceptHandlers, "f").reduce((promiseChain, interceptAction) => {
      return promiseChain.then(interceptAction);
    }, Promise.resolve());
    const { action } = this.interceptResolutionState();
    switch (action) {
      case "abort":
        return __classPrivateFieldGet12(this, _HTTPRequest_instances, "m", _HTTPRequest_abort).call(this, __classPrivateFieldGet12(this, _HTTPRequest_abortErrorReason, "f"));
      case "respond":
        if (__classPrivateFieldGet12(this, _HTTPRequest_responseForRequest, "f") === null) {
          throw new Error("Response is missing for the interception");
        }
        return __classPrivateFieldGet12(this, _HTTPRequest_instances, "m", _HTTPRequest_respond).call(this, __classPrivateFieldGet12(this, _HTTPRequest_responseForRequest, "f"));
      case "continue":
        return __classPrivateFieldGet12(this, _HTTPRequest_instances, "m", _HTTPRequest_continue).call(this, __classPrivateFieldGet12(this, _HTTPRequest_continueRequestOverrides, "f"));
    }
  }
  resourceType() {
    return __classPrivateFieldGet12(this, _HTTPRequest_resourceType, "f");
  }
  method() {
    return __classPrivateFieldGet12(this, _HTTPRequest_method, "f");
  }
  postData() {
    return __classPrivateFieldGet12(this, _HTTPRequest_postData, "f");
  }
  headers() {
    return __classPrivateFieldGet12(this, _HTTPRequest_headers, "f");
  }
  response() {
    return this._response;
  }
  frame() {
    return __classPrivateFieldGet12(this, _HTTPRequest_frame, "f");
  }
  isNavigationRequest() {
    return __classPrivateFieldGet12(this, _HTTPRequest_isNavigationRequest, "f");
  }
  initiator() {
    return __classPrivateFieldGet12(this, _HTTPRequest_initiator, "f");
  }
  redirectChain() {
    return this._redirectChain.slice();
  }
  failure() {
    if (!this._failureText) {
      return null;
    }
    return {
      errorText: this._failureText
    };
  }
  async continue(overrides = {}, priority) {
    if (__classPrivateFieldGet12(this, _HTTPRequest_url, "f").startsWith("data:")) {
      return;
    }
    assert(__classPrivateFieldGet12(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
    assert(!__classPrivateFieldGet12(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
    if (priority === void 0) {
      return __classPrivateFieldGet12(this, _HTTPRequest_instances, "m", _HTTPRequest_continue).call(this, overrides);
    }
    __classPrivateFieldSet9(this, _HTTPRequest_continueRequestOverrides, overrides, "f");
    if (__classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority === void 0 || priority > __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority) {
      __classPrivateFieldSet9(this, _HTTPRequest_interceptResolutionState, {
        action: InterceptResolutionAction.Continue,
        priority
      }, "f");
      return;
    }
    if (priority === __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority) {
      if (__classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").action === "abort" || __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").action === "respond") {
        return;
      }
      __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").action = InterceptResolutionAction.Continue;
    }
    return;
  }
  async respond(response, priority) {
    if (__classPrivateFieldGet12(this, _HTTPRequest_url, "f").startsWith("data:")) {
      return;
    }
    assert(__classPrivateFieldGet12(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
    assert(!__classPrivateFieldGet12(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
    if (priority === void 0) {
      return __classPrivateFieldGet12(this, _HTTPRequest_instances, "m", _HTTPRequest_respond).call(this, response);
    }
    __classPrivateFieldSet9(this, _HTTPRequest_responseForRequest, response, "f");
    if (__classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority === void 0 || priority > __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority) {
      __classPrivateFieldSet9(this, _HTTPRequest_interceptResolutionState, {
        action: InterceptResolutionAction.Respond,
        priority
      }, "f");
      return;
    }
    if (priority === __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority) {
      if (__classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").action === "abort") {
        return;
      }
      __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").action = InterceptResolutionAction.Respond;
    }
  }
  async abort(errorCode = "failed", priority) {
    if (__classPrivateFieldGet12(this, _HTTPRequest_url, "f").startsWith("data:")) {
      return;
    }
    const errorReason = errorReasons[errorCode];
    assert(errorReason, "Unknown error code: " + errorCode);
    assert(__classPrivateFieldGet12(this, _HTTPRequest_allowInterception, "f"), "Request Interception is not enabled!");
    assert(!__classPrivateFieldGet12(this, _HTTPRequest_interceptionHandled, "f"), "Request is already handled!");
    if (priority === void 0) {
      return __classPrivateFieldGet12(this, _HTTPRequest_instances, "m", _HTTPRequest_abort).call(this, errorReason);
    }
    __classPrivateFieldSet9(this, _HTTPRequest_abortErrorReason, errorReason, "f");
    if (__classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority === void 0 || priority >= __classPrivateFieldGet12(this, _HTTPRequest_interceptResolutionState, "f").priority) {
      __classPrivateFieldSet9(this, _HTTPRequest_interceptResolutionState, {
        action: InterceptResolutionAction.Abort,
        priority
      }, "f");
      return;
    }
  }
};
_HTTPRequest_client = /* @__PURE__ */ new WeakMap(), _HTTPRequest_isNavigationRequest = /* @__PURE__ */ new WeakMap(), _HTTPRequest_allowInterception = /* @__PURE__ */ new WeakMap(), _HTTPRequest_interceptionHandled = /* @__PURE__ */ new WeakMap(), _HTTPRequest_url = /* @__PURE__ */ new WeakMap(), _HTTPRequest_resourceType = /* @__PURE__ */ new WeakMap(), _HTTPRequest_method = /* @__PURE__ */ new WeakMap(), _HTTPRequest_postData = /* @__PURE__ */ new WeakMap(), _HTTPRequest_headers = /* @__PURE__ */ new WeakMap(), _HTTPRequest_frame = /* @__PURE__ */ new WeakMap(), _HTTPRequest_continueRequestOverrides = /* @__PURE__ */ new WeakMap(), _HTTPRequest_responseForRequest = /* @__PURE__ */ new WeakMap(), _HTTPRequest_abortErrorReason = /* @__PURE__ */ new WeakMap(), _HTTPRequest_interceptResolutionState = /* @__PURE__ */ new WeakMap(), _HTTPRequest_interceptHandlers = /* @__PURE__ */ new WeakMap(), _HTTPRequest_initiator = /* @__PURE__ */ new WeakMap(), _HTTPRequest_instances = /* @__PURE__ */ new WeakSet(), _HTTPRequest_continue = async function _HTTPRequest_continue2(overrides = {}) {
  const { url, method, postData, headers } = overrides;
  __classPrivateFieldSet9(this, _HTTPRequest_interceptionHandled, true, "f");
  const postDataBinaryBase64 = postData ? Buffer.from(postData).toString("base64") : void 0;
  if (this._interceptionId === void 0) {
    throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
  }
  await __classPrivateFieldGet12(this, _HTTPRequest_client, "f").send("Fetch.continueRequest", {
    requestId: this._interceptionId,
    url,
    method,
    postData: postDataBinaryBase64,
    headers: headers ? headersArray(headers) : void 0
  }).catch((error) => {
    __classPrivateFieldSet9(this, _HTTPRequest_interceptionHandled, false, "f");
    return handleError(error);
  });
}, _HTTPRequest_respond = async function _HTTPRequest_respond2(response) {
  __classPrivateFieldSet9(this, _HTTPRequest_interceptionHandled, true, "f");
  const responseBody = response.body && isString(response.body) ? Buffer.from(response.body) : response.body || null;
  const responseHeaders = {};
  if (response.headers) {
    for (const header of Object.keys(response.headers)) {
      const value = response.headers[header];
      responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
        return String(item);
      }) : String(value);
    }
  }
  if (response.contentType) {
    responseHeaders["content-type"] = response.contentType;
  }
  if (responseBody && !("content-length" in responseHeaders)) {
    responseHeaders["content-length"] = String(Buffer.byteLength(responseBody));
  }
  const status = response.status || 200;
  if (this._interceptionId === void 0) {
    throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
  }
  await __classPrivateFieldGet12(this, _HTTPRequest_client, "f").send("Fetch.fulfillRequest", {
    requestId: this._interceptionId,
    responseCode: status,
    responsePhrase: STATUS_TEXTS[status],
    responseHeaders: headersArray(responseHeaders),
    body: responseBody ? responseBody.toString("base64") : void 0
  }).catch((error) => {
    __classPrivateFieldSet9(this, _HTTPRequest_interceptionHandled, false, "f");
    return handleError(error);
  });
}, _HTTPRequest_abort = async function _HTTPRequest_abort2(errorReason) {
  __classPrivateFieldSet9(this, _HTTPRequest_interceptionHandled, true, "f");
  if (this._interceptionId === void 0) {
    throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
  }
  await __classPrivateFieldGet12(this, _HTTPRequest_client, "f").send("Fetch.failRequest", {
    requestId: this._interceptionId,
    errorReason: errorReason || "Failed"
  }).catch(handleError);
};
var errorReasons = {
  aborted: "Aborted",
  accessdenied: "AccessDenied",
  addressunreachable: "AddressUnreachable",
  blockedbyclient: "BlockedByClient",
  blockedbyresponse: "BlockedByResponse",
  connectionaborted: "ConnectionAborted",
  connectionclosed: "ConnectionClosed",
  connectionfailed: "ConnectionFailed",
  connectionrefused: "ConnectionRefused",
  connectionreset: "ConnectionReset",
  internetdisconnected: "InternetDisconnected",
  namenotresolved: "NameNotResolved",
  timedout: "TimedOut",
  failed: "Failed"
};
async function handleError(error) {
  if (["Invalid header"].includes(error.originalMessage)) {
    throw error;
  }
  debugError(error);
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/HTTPResponse.js
var __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet13 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTTPResponse_instances;
var _HTTPResponse_client;
var _HTTPResponse_request;
var _HTTPResponse_contentPromise;
var _HTTPResponse_bodyLoadedDeferred;
var _HTTPResponse_remoteAddress;
var _HTTPResponse_status;
var _HTTPResponse_statusText;
var _HTTPResponse_url;
var _HTTPResponse_fromDiskCache;
var _HTTPResponse_fromServiceWorker;
var _HTTPResponse_headers;
var _HTTPResponse_securityDetails;
var _HTTPResponse_timing;
var _HTTPResponse_parseStatusTextFromExtrInfo;
var HTTPResponse2 = class extends HTTPResponse {
  constructor(client, request, responsePayload, extraInfo) {
    super();
    _HTTPResponse_instances.add(this);
    _HTTPResponse_client.set(this, void 0);
    _HTTPResponse_request.set(this, void 0);
    _HTTPResponse_contentPromise.set(this, null);
    _HTTPResponse_bodyLoadedDeferred.set(this, Deferred.create());
    _HTTPResponse_remoteAddress.set(this, void 0);
    _HTTPResponse_status.set(this, void 0);
    _HTTPResponse_statusText.set(this, void 0);
    _HTTPResponse_url.set(this, void 0);
    _HTTPResponse_fromDiskCache.set(this, void 0);
    _HTTPResponse_fromServiceWorker.set(this, void 0);
    _HTTPResponse_headers.set(this, {});
    _HTTPResponse_securityDetails.set(this, void 0);
    _HTTPResponse_timing.set(this, void 0);
    __classPrivateFieldSet10(this, _HTTPResponse_client, client, "f");
    __classPrivateFieldSet10(this, _HTTPResponse_request, request, "f");
    __classPrivateFieldSet10(this, _HTTPResponse_remoteAddress, {
      ip: responsePayload.remoteIPAddress,
      port: responsePayload.remotePort
    }, "f");
    __classPrivateFieldSet10(this, _HTTPResponse_statusText, __classPrivateFieldGet13(this, _HTTPResponse_instances, "m", _HTTPResponse_parseStatusTextFromExtrInfo).call(this, extraInfo) || responsePayload.statusText, "f");
    __classPrivateFieldSet10(this, _HTTPResponse_url, request.url(), "f");
    __classPrivateFieldSet10(this, _HTTPResponse_fromDiskCache, !!responsePayload.fromDiskCache, "f");
    __classPrivateFieldSet10(this, _HTTPResponse_fromServiceWorker, !!responsePayload.fromServiceWorker, "f");
    __classPrivateFieldSet10(this, _HTTPResponse_status, extraInfo ? extraInfo.statusCode : responsePayload.status, "f");
    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
    for (const [key, value] of Object.entries(headers)) {
      __classPrivateFieldGet13(this, _HTTPResponse_headers, "f")[key.toLowerCase()] = value;
    }
    __classPrivateFieldSet10(this, _HTTPResponse_securityDetails, responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null, "f");
    __classPrivateFieldSet10(this, _HTTPResponse_timing, responsePayload.timing || null, "f");
  }
  _resolveBody(err) {
    if (err) {
      return __classPrivateFieldGet13(this, _HTTPResponse_bodyLoadedDeferred, "f").resolve(err);
    }
    return __classPrivateFieldGet13(this, _HTTPResponse_bodyLoadedDeferred, "f").resolve();
  }
  remoteAddress() {
    return __classPrivateFieldGet13(this, _HTTPResponse_remoteAddress, "f");
  }
  url() {
    return __classPrivateFieldGet13(this, _HTTPResponse_url, "f");
  }
  status() {
    return __classPrivateFieldGet13(this, _HTTPResponse_status, "f");
  }
  statusText() {
    return __classPrivateFieldGet13(this, _HTTPResponse_statusText, "f");
  }
  headers() {
    return __classPrivateFieldGet13(this, _HTTPResponse_headers, "f");
  }
  securityDetails() {
    return __classPrivateFieldGet13(this, _HTTPResponse_securityDetails, "f");
  }
  timing() {
    return __classPrivateFieldGet13(this, _HTTPResponse_timing, "f");
  }
  buffer() {
    if (!__classPrivateFieldGet13(this, _HTTPResponse_contentPromise, "f")) {
      __classPrivateFieldSet10(this, _HTTPResponse_contentPromise, __classPrivateFieldGet13(this, _HTTPResponse_bodyLoadedDeferred, "f").valueOrThrow().then(async (error) => {
        if (error) {
          throw error;
        }
        try {
          const response = await __classPrivateFieldGet13(this, _HTTPResponse_client, "f").send("Network.getResponseBody", {
            requestId: __classPrivateFieldGet13(this, _HTTPResponse_request, "f")._requestId
          });
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        } catch (error2) {
          if (error2 instanceof ProtocolError && error2.originalMessage === "No resource with given identifier found") {
            throw new ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
          }
          throw error2;
        }
      }), "f");
    }
    return __classPrivateFieldGet13(this, _HTTPResponse_contentPromise, "f");
  }
  request() {
    return __classPrivateFieldGet13(this, _HTTPResponse_request, "f");
  }
  fromCache() {
    return __classPrivateFieldGet13(this, _HTTPResponse_fromDiskCache, "f") || __classPrivateFieldGet13(this, _HTTPResponse_request, "f")._fromMemoryCache;
  }
  fromServiceWorker() {
    return __classPrivateFieldGet13(this, _HTTPResponse_fromServiceWorker, "f");
  }
  frame() {
    return __classPrivateFieldGet13(this, _HTTPResponse_request, "f").frame();
  }
};
_HTTPResponse_client = /* @__PURE__ */ new WeakMap(), _HTTPResponse_request = /* @__PURE__ */ new WeakMap(), _HTTPResponse_contentPromise = /* @__PURE__ */ new WeakMap(), _HTTPResponse_bodyLoadedDeferred = /* @__PURE__ */ new WeakMap(), _HTTPResponse_remoteAddress = /* @__PURE__ */ new WeakMap(), _HTTPResponse_status = /* @__PURE__ */ new WeakMap(), _HTTPResponse_statusText = /* @__PURE__ */ new WeakMap(), _HTTPResponse_url = /* @__PURE__ */ new WeakMap(), _HTTPResponse_fromDiskCache = /* @__PURE__ */ new WeakMap(), _HTTPResponse_fromServiceWorker = /* @__PURE__ */ new WeakMap(), _HTTPResponse_headers = /* @__PURE__ */ new WeakMap(), _HTTPResponse_securityDetails = /* @__PURE__ */ new WeakMap(), _HTTPResponse_timing = /* @__PURE__ */ new WeakMap(), _HTTPResponse_instances = /* @__PURE__ */ new WeakSet(), _HTTPResponse_parseStatusTextFromExtrInfo = function _HTTPResponse_parseStatusTextFromExtrInfo2(extraInfo) {
  if (!extraInfo || !extraInfo.headersText) {
    return;
  }
  const firstLine = extraInfo.headersText.split("\r", 1)[0];
  if (!firstLine) {
    return;
  }
  const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
  if (!match) {
    return;
  }
  const statusText = match[1];
  if (!statusText) {
    return;
  }
  return statusText;
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManager.js
var __classPrivateFieldSet11 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet14 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NetworkManager_instances;
var _NetworkManager_client;
var _NetworkManager_ignoreHTTPSErrors;
var _NetworkManager_frameManager;
var _NetworkManager_networkEventManager;
var _NetworkManager_extraHTTPHeaders;
var _NetworkManager_credentials;
var _NetworkManager_attemptedAuthentications;
var _NetworkManager_userRequestInterceptionEnabled;
var _NetworkManager_protocolRequestInterceptionEnabled;
var _NetworkManager_userCacheDisabled;
var _NetworkManager_emulatedNetworkConditions;
var _NetworkManager_deferredInit;
var _NetworkManager_updateNetworkConditions;
var _NetworkManager_updateProtocolRequestInterception;
var _NetworkManager_cacheDisabled;
var _NetworkManager_updateProtocolCacheDisabled;
var _NetworkManager_onRequestWillBeSent;
var _NetworkManager_onAuthRequired;
var _NetworkManager_onRequestPaused;
var _NetworkManager_patchRequestEventHeaders;
var _NetworkManager_onRequestWithoutNetworkInstrumentation;
var _NetworkManager_onRequest;
var _NetworkManager_onRequestServedFromCache;
var _NetworkManager_handleRequestRedirect;
var _NetworkManager_emitResponseEvent;
var _NetworkManager_onResponseReceived;
var _NetworkManager_onResponseReceivedExtraInfo;
var _NetworkManager_forgetRequest;
var _NetworkManager_onLoadingFinished;
var _NetworkManager_emitLoadingFinished;
var _NetworkManager_onLoadingFailed;
var _NetworkManager_emitLoadingFailed;
var NetworkManagerEmittedEvents = {
  Request: Symbol("NetworkManager.Request"),
  RequestServedFromCache: Symbol("NetworkManager.RequestServedFromCache"),
  Response: Symbol("NetworkManager.Response"),
  RequestFailed: Symbol("NetworkManager.RequestFailed"),
  RequestFinished: Symbol("NetworkManager.RequestFinished")
};
var NetworkManager = class extends EventEmitter {
  constructor(client, ignoreHTTPSErrors, frameManager) {
    super();
    _NetworkManager_instances.add(this);
    _NetworkManager_client.set(this, void 0);
    _NetworkManager_ignoreHTTPSErrors.set(this, void 0);
    _NetworkManager_frameManager.set(this, void 0);
    _NetworkManager_networkEventManager.set(this, new NetworkEventManager());
    _NetworkManager_extraHTTPHeaders.set(this, {});
    _NetworkManager_credentials.set(this, void 0);
    _NetworkManager_attemptedAuthentications.set(this, /* @__PURE__ */ new Set());
    _NetworkManager_userRequestInterceptionEnabled.set(this, false);
    _NetworkManager_protocolRequestInterceptionEnabled.set(this, false);
    _NetworkManager_userCacheDisabled.set(this, false);
    _NetworkManager_emulatedNetworkConditions.set(this, {
      offline: false,
      upload: -1,
      download: -1,
      latency: 0
    });
    _NetworkManager_deferredInit.set(this, void 0);
    __classPrivateFieldSet11(this, _NetworkManager_client, client, "f");
    __classPrivateFieldSet11(this, _NetworkManager_ignoreHTTPSErrors, ignoreHTTPSErrors, "f");
    __classPrivateFieldSet11(this, _NetworkManager_frameManager, frameManager, "f");
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Fetch.requestPaused", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequestPaused).bind(this));
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Fetch.authRequired", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onAuthRequired).bind(this));
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Network.requestWillBeSent", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequestWillBeSent).bind(this));
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Network.requestServedFromCache", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequestServedFromCache).bind(this));
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Network.responseReceived", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onResponseReceived).bind(this));
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Network.loadingFinished", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onLoadingFinished).bind(this));
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Network.loadingFailed", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onLoadingFailed).bind(this));
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").on("Network.responseReceivedExtraInfo", __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onResponseReceivedExtraInfo).bind(this));
  }
  initialize() {
    if (__classPrivateFieldGet14(this, _NetworkManager_deferredInit, "f")) {
      return __classPrivateFieldGet14(this, _NetworkManager_deferredInit, "f").valueOrThrow();
    }
    __classPrivateFieldSet11(this, _NetworkManager_deferredInit, createDebuggableDeferred("NetworkManager initialization timed out"), "f");
    const init = Promise.all([
      __classPrivateFieldGet14(this, _NetworkManager_ignoreHTTPSErrors, "f") ? __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Security.setIgnoreCertificateErrors", {
        ignore: true
      }) : null,
      __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Network.enable")
    ]);
    const deferredInitPromise = __classPrivateFieldGet14(this, _NetworkManager_deferredInit, "f");
    init.then(() => {
      deferredInitPromise.resolve();
    }).catch((err) => {
      deferredInitPromise.reject(err);
    });
    return __classPrivateFieldGet14(this, _NetworkManager_deferredInit, "f").valueOrThrow();
  }
  async authenticate(credentials) {
    __classPrivateFieldSet11(this, _NetworkManager_credentials, credentials, "f");
    await __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolRequestInterception).call(this);
  }
  async setExtraHTTPHeaders(extraHTTPHeaders) {
    __classPrivateFieldSet11(this, _NetworkManager_extraHTTPHeaders, {}, "f");
    for (const key of Object.keys(extraHTTPHeaders)) {
      const value = extraHTTPHeaders[key];
      assert(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      __classPrivateFieldGet14(this, _NetworkManager_extraHTTPHeaders, "f")[key.toLowerCase()] = value;
    }
    await __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Network.setExtraHTTPHeaders", {
      headers: __classPrivateFieldGet14(this, _NetworkManager_extraHTTPHeaders, "f")
    });
  }
  extraHTTPHeaders() {
    return Object.assign({}, __classPrivateFieldGet14(this, _NetworkManager_extraHTTPHeaders, "f"));
  }
  inFlightRequestsCount() {
    return __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").inFlightRequestsCount();
  }
  async setOfflineMode(value) {
    __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").offline = value;
    await __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_updateNetworkConditions).call(this);
  }
  async emulateNetworkConditions(networkConditions) {
    __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").upload = networkConditions ? networkConditions.upload : -1;
    __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").download = networkConditions ? networkConditions.download : -1;
    __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").latency = networkConditions ? networkConditions.latency : 0;
    await __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_updateNetworkConditions).call(this);
  }
  async setUserAgent(userAgent, userAgentMetadata) {
    await __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Network.setUserAgentOverride", {
      userAgent,
      userAgentMetadata
    });
  }
  async setCacheEnabled(enabled) {
    __classPrivateFieldSet11(this, _NetworkManager_userCacheDisabled, !enabled, "f");
    await __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this);
  }
  async setRequestInterception(value) {
    __classPrivateFieldSet11(this, _NetworkManager_userRequestInterceptionEnabled, value, "f");
    await __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolRequestInterception).call(this);
  }
};
_NetworkManager_client = /* @__PURE__ */ new WeakMap(), _NetworkManager_ignoreHTTPSErrors = /* @__PURE__ */ new WeakMap(), _NetworkManager_frameManager = /* @__PURE__ */ new WeakMap(), _NetworkManager_networkEventManager = /* @__PURE__ */ new WeakMap(), _NetworkManager_extraHTTPHeaders = /* @__PURE__ */ new WeakMap(), _NetworkManager_credentials = /* @__PURE__ */ new WeakMap(), _NetworkManager_attemptedAuthentications = /* @__PURE__ */ new WeakMap(), _NetworkManager_userRequestInterceptionEnabled = /* @__PURE__ */ new WeakMap(), _NetworkManager_protocolRequestInterceptionEnabled = /* @__PURE__ */ new WeakMap(), _NetworkManager_userCacheDisabled = /* @__PURE__ */ new WeakMap(), _NetworkManager_emulatedNetworkConditions = /* @__PURE__ */ new WeakMap(), _NetworkManager_deferredInit = /* @__PURE__ */ new WeakMap(), _NetworkManager_instances = /* @__PURE__ */ new WeakSet(), _NetworkManager_updateNetworkConditions = async function _NetworkManager_updateNetworkConditions2() {
  await __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Network.emulateNetworkConditions", {
    offline: __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").offline,
    latency: __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").latency,
    uploadThroughput: __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").upload,
    downloadThroughput: __classPrivateFieldGet14(this, _NetworkManager_emulatedNetworkConditions, "f").download
  });
}, _NetworkManager_updateProtocolRequestInterception = async function _NetworkManager_updateProtocolRequestInterception2() {
  const enabled = __classPrivateFieldGet14(this, _NetworkManager_userRequestInterceptionEnabled, "f") || !!__classPrivateFieldGet14(this, _NetworkManager_credentials, "f");
  if (enabled === __classPrivateFieldGet14(this, _NetworkManager_protocolRequestInterceptionEnabled, "f")) {
    return;
  }
  __classPrivateFieldSet11(this, _NetworkManager_protocolRequestInterceptionEnabled, enabled, "f");
  if (enabled) {
    await Promise.all([
      __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this),
      __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Fetch.enable", {
        handleAuthRequests: true,
        patterns: [{ urlPattern: "*" }]
      })
    ]);
  } else {
    await Promise.all([
      __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_updateProtocolCacheDisabled).call(this),
      __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Fetch.disable")
    ]);
  }
}, _NetworkManager_cacheDisabled = function _NetworkManager_cacheDisabled2() {
  return __classPrivateFieldGet14(this, _NetworkManager_userCacheDisabled, "f");
}, _NetworkManager_updateProtocolCacheDisabled = async function _NetworkManager_updateProtocolCacheDisabled2() {
  await __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Network.setCacheDisabled", {
    cacheDisabled: __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_cacheDisabled).call(this)
  });
}, _NetworkManager_onRequestWillBeSent = function _NetworkManager_onRequestWillBeSent2(event) {
  if (__classPrivateFieldGet14(this, _NetworkManager_userRequestInterceptionEnabled, "f") && !event.request.url.startsWith("data:")) {
    const { requestId: networkRequestId } = event;
    __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").storeRequestWillBeSent(networkRequestId, event);
    const requestPausedEvent = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequestPaused(networkRequestId);
    if (requestPausedEvent) {
      const { requestId: fetchRequestId } = requestPausedEvent;
      __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_patchRequestEventHeaders).call(this, event, requestPausedEvent);
      __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, event, fetchRequestId);
      __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").forgetRequestPaused(networkRequestId);
    }
    return;
  }
  __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, event, void 0);
}, _NetworkManager_onAuthRequired = function _NetworkManager_onAuthRequired2(event) {
  let response = "Default";
  if (__classPrivateFieldGet14(this, _NetworkManager_attemptedAuthentications, "f").has(event.requestId)) {
    response = "CancelAuth";
  } else if (__classPrivateFieldGet14(this, _NetworkManager_credentials, "f")) {
    response = "ProvideCredentials";
    __classPrivateFieldGet14(this, _NetworkManager_attemptedAuthentications, "f").add(event.requestId);
  }
  const { username, password } = __classPrivateFieldGet14(this, _NetworkManager_credentials, "f") || {
    username: void 0,
    password: void 0
  };
  __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Fetch.continueWithAuth", {
    requestId: event.requestId,
    authChallengeResponse: { response, username, password }
  }).catch(debugError);
}, _NetworkManager_onRequestPaused = function _NetworkManager_onRequestPaused2(event) {
  if (!__classPrivateFieldGet14(this, _NetworkManager_userRequestInterceptionEnabled, "f") && __classPrivateFieldGet14(this, _NetworkManager_protocolRequestInterceptionEnabled, "f")) {
    __classPrivateFieldGet14(this, _NetworkManager_client, "f").send("Fetch.continueRequest", {
      requestId: event.requestId
    }).catch(debugError);
  }
  const { networkId: networkRequestId, requestId: fetchRequestId } = event;
  if (!networkRequestId) {
    __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequestWithoutNetworkInstrumentation).call(this, event);
    return;
  }
  const requestWillBeSentEvent = (() => {
    const requestWillBeSentEvent2 = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequestWillBeSent(networkRequestId);
    if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
      __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").forgetRequestWillBeSent(networkRequestId);
      return;
    }
    return requestWillBeSentEvent2;
  })();
  if (requestWillBeSentEvent) {
    __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_patchRequestEventHeaders).call(this, requestWillBeSentEvent, event);
    __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, requestWillBeSentEvent, fetchRequestId);
  } else {
    __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").storeRequestPaused(networkRequestId, event);
  }
}, _NetworkManager_patchRequestEventHeaders = function _NetworkManager_patchRequestEventHeaders2(requestWillBeSentEvent, requestPausedEvent) {
  requestWillBeSentEvent.request.headers = {
    ...requestWillBeSentEvent.request.headers,
    ...requestPausedEvent.request.headers
  };
}, _NetworkManager_onRequestWithoutNetworkInstrumentation = function _NetworkManager_onRequestWithoutNetworkInstrumentation2(event) {
  const frame = event.frameId ? __classPrivateFieldGet14(this, _NetworkManager_frameManager, "f").frame(event.frameId) : null;
  const request = new HTTPRequest2(__classPrivateFieldGet14(this, _NetworkManager_client, "f"), frame, event.requestId, __classPrivateFieldGet14(this, _NetworkManager_userRequestInterceptionEnabled, "f"), event, []);
  this.emit(NetworkManagerEmittedEvents.Request, request);
  void request.finalizeInterceptions();
}, _NetworkManager_onRequest = function _NetworkManager_onRequest2(event, fetchRequestId) {
  let redirectChain = [];
  if (event.redirectResponse) {
    let redirectResponseExtraInfo = null;
    if (event.redirectHasExtraInfo) {
      redirectResponseExtraInfo = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).shift();
      if (!redirectResponseExtraInfo) {
        __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").queueRedirectInfo(event.requestId, {
          event,
          fetchRequestId
        });
        return;
      }
    }
    const request2 = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
    if (request2) {
      __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_handleRequestRedirect).call(this, request2, event.redirectResponse, redirectResponseExtraInfo);
      redirectChain = request2._redirectChain;
    }
  }
  const frame = event.frameId ? __classPrivateFieldGet14(this, _NetworkManager_frameManager, "f").frame(event.frameId) : null;
  const request = new HTTPRequest2(__classPrivateFieldGet14(this, _NetworkManager_client, "f"), frame, fetchRequestId, __classPrivateFieldGet14(this, _NetworkManager_userRequestInterceptionEnabled, "f"), event, redirectChain);
  __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").storeRequest(event.requestId, request);
  this.emit(NetworkManagerEmittedEvents.Request, request);
  void request.finalizeInterceptions();
}, _NetworkManager_onRequestServedFromCache = function _NetworkManager_onRequestServedFromCache2(event) {
  const request = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
  if (request) {
    request._fromMemoryCache = true;
  }
  this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);
}, _NetworkManager_handleRequestRedirect = function _NetworkManager_handleRequestRedirect2(request, responsePayload, extraInfo) {
  const response = new HTTPResponse2(__classPrivateFieldGet14(this, _NetworkManager_client, "f"), request, responsePayload, extraInfo);
  request._response = response;
  request._redirectChain.push(request);
  response._resolveBody(new Error("Response body is unavailable for redirect responses"));
  __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, false);
  this.emit(NetworkManagerEmittedEvents.Response, response);
  this.emit(NetworkManagerEmittedEvents.RequestFinished, request);
}, _NetworkManager_emitResponseEvent = function _NetworkManager_emitResponseEvent2(responseReceived, extraInfo) {
  const request = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequest(responseReceived.requestId);
  if (!request) {
    return;
  }
  const extraInfos = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(responseReceived.requestId);
  if (extraInfos.length) {
    debugError(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
  }
  if (responseReceived.response.fromDiskCache) {
    extraInfo = null;
  }
  const response = new HTTPResponse2(__classPrivateFieldGet14(this, _NetworkManager_client, "f"), request, responseReceived.response, extraInfo);
  request._response = response;
  this.emit(NetworkManagerEmittedEvents.Response, response);
}, _NetworkManager_onResponseReceived = function _NetworkManager_onResponseReceived2(event) {
  const request = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
  let extraInfo = null;
  if (request && !request._fromMemoryCache && event.hasExtraInfo) {
    extraInfo = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).shift();
    if (!extraInfo) {
      __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").queueEventGroup(event.requestId, {
        responseReceivedEvent: event
      });
      return;
    }
  }
  __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_emitResponseEvent).call(this, event, extraInfo);
}, _NetworkManager_onResponseReceivedExtraInfo = function _NetworkManager_onResponseReceivedExtraInfo2(event) {
  const redirectInfo = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").takeQueuedRedirectInfo(event.requestId);
  if (redirectInfo) {
    __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).push(event);
    __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_onRequest).call(this, redirectInfo.event, redirectInfo.fetchRequestId);
    return;
  }
  const queuedEvents = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
  if (queuedEvents) {
    __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").forgetQueuedEventGroup(event.requestId);
    __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_emitResponseEvent).call(this, queuedEvents.responseReceivedEvent, event);
    if (queuedEvents.loadingFinishedEvent) {
      __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFinished).call(this, queuedEvents.loadingFinishedEvent);
    }
    if (queuedEvents.loadingFailedEvent) {
      __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFailed).call(this, queuedEvents.loadingFailedEvent);
    }
    return;
  }
  __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").responseExtraInfo(event.requestId).push(event);
}, _NetworkManager_forgetRequest = function _NetworkManager_forgetRequest2(request, events) {
  const requestId = request._requestId;
  const interceptionId = request._interceptionId;
  __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").forgetRequest(requestId);
  interceptionId !== void 0 && __classPrivateFieldGet14(this, _NetworkManager_attemptedAuthentications, "f").delete(interceptionId);
  if (events) {
    __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").forget(requestId);
  }
}, _NetworkManager_onLoadingFinished = function _NetworkManager_onLoadingFinished2(event) {
  const queuedEvents = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
  if (queuedEvents) {
    queuedEvents.loadingFinishedEvent = event;
  } else {
    __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFinished).call(this, event);
  }
}, _NetworkManager_emitLoadingFinished = function _NetworkManager_emitLoadingFinished2(event) {
  var _a2;
  const request = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
  if (!request) {
    return;
  }
  if (request.response()) {
    (_a2 = request.response()) == null ? void 0 : _a2._resolveBody(null);
  }
  __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, true);
  this.emit(NetworkManagerEmittedEvents.RequestFinished, request);
}, _NetworkManager_onLoadingFailed = function _NetworkManager_onLoadingFailed2(event) {
  const queuedEvents = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getQueuedEventGroup(event.requestId);
  if (queuedEvents) {
    queuedEvents.loadingFailedEvent = event;
  } else {
    __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_emitLoadingFailed).call(this, event);
  }
}, _NetworkManager_emitLoadingFailed = function _NetworkManager_emitLoadingFailed2(event) {
  const request = __classPrivateFieldGet14(this, _NetworkManager_networkEventManager, "f").getRequest(event.requestId);
  if (!request) {
    return;
  }
  request._failureText = event.errorText;
  const response = request.response();
  if (response) {
    response._resolveBody(null);
  }
  __classPrivateFieldGet14(this, _NetworkManager_instances, "m", _NetworkManager_forgetRequest).call(this, request, true);
  this.emit(NetworkManagerEmittedEvents.RequestFailed, request);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js
var paperFormats = {
  letter: { width: 8.5, height: 11 },
  legal: { width: 8.5, height: 14 },
  tabloid: { width: 11, height: 17 },
  ledger: { width: 17, height: 11 },
  a0: { width: 33.1, height: 46.8 },
  a1: { width: 23.4, height: 33.1 },
  a2: { width: 16.54, height: 23.4 },
  a3: { width: 11.7, height: 16.54 },
  a4: { width: 8.27, height: 11.7 },
  a5: { width: 5.83, height: 8.27 },
  a6: { width: 4.13, height: 5.83 }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Locator.js
var __classPrivateFieldSet12 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet15 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LocatorImpl_instances;
var _LocatorImpl_pageOrFrame;
var _LocatorImpl_selector;
var _LocatorImpl_visibility;
var _LocatorImpl_timeout;
var _LocatorImpl_ensureElementIsInTheViewport;
var _LocatorImpl_waitForEnabled;
var _LocatorImpl_waitForStableBoundingBox;
var _LocatorImpl_waitForFunction;
var _LocatorImpl_ensureElementIsInTheViewportIfNeeded;
var _LocatorImpl_waitForVisibilityIfNeeded;
var _LocatorImpl_waitForEnabledIfNeeded;
var _LocatorImpl_waitForStableBoundingBoxIfNeeded;
var _LocatorImpl_run;
var _RaceLocatorImpl_instances;
var _RaceLocatorImpl_locators;
var _RaceLocatorImpl_runRace;
var CONDITION_TIMEOUT = 1e3;
var WAIT_FOR_FUNCTION_DELAY = 100;
var LocatorEmittedEvents;
(function(LocatorEmittedEvents2) {
  LocatorEmittedEvents2["Action"] = "action";
})(LocatorEmittedEvents || (LocatorEmittedEvents = {}));
var Locator = class extends EventEmitter {
  static create(pageOrFrame, selector) {
    return new LocatorImpl(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
  }
  static race(locators) {
    return new RaceLocatorImpl(locators);
  }
  on(eventName, handler) {
    return super.on(eventName, handler);
  }
  once(eventName, handler) {
    return super.once(eventName, handler);
  }
  off(eventName, handler) {
    return super.off(eventName, handler);
  }
};
var LocatorImpl = class extends Locator {
  constructor(pageOrFrame, selector) {
    super();
    _LocatorImpl_instances.add(this);
    _LocatorImpl_pageOrFrame.set(this, void 0);
    _LocatorImpl_selector.set(this, void 0);
    _LocatorImpl_visibility.set(this, "visible");
    _LocatorImpl_timeout.set(this, 3e4);
    _LocatorImpl_ensureElementIsInTheViewport.set(this, true);
    _LocatorImpl_waitForEnabled.set(this, true);
    _LocatorImpl_waitForStableBoundingBox.set(this, true);
    _LocatorImpl_ensureElementIsInTheViewportIfNeeded.set(this, async (element, signal) => {
      if (!__classPrivateFieldGet15(this, _LocatorImpl_ensureElementIsInTheViewport, "f")) {
        return;
      }
      const isIntersectingViewport = await element.isIntersectingViewport({
        threshold: 0
      });
      signal == null ? void 0 : signal.throwIfAborted();
      if (!isIntersectingViewport) {
        await element.scrollIntoView();
        signal == null ? void 0 : signal.throwIfAborted();
        await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_waitForFunction).call(this, async () => {
          return await element.isIntersectingViewport({
            threshold: 0
          });
        }, signal);
        signal == null ? void 0 : signal.throwIfAborted();
      }
    });
    _LocatorImpl_waitForVisibilityIfNeeded.set(this, async (element, signal) => {
      if (__classPrivateFieldGet15(this, _LocatorImpl_visibility, "f") === null) {
        return;
      }
      if (__classPrivateFieldGet15(this, _LocatorImpl_visibility, "f") === "hidden") {
        await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_waitForFunction).call(this, async () => {
          return element.isHidden();
        }, signal);
      }
      await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_waitForFunction).call(this, async () => {
        return element.isVisible();
      }, signal);
    });
    _LocatorImpl_waitForEnabledIfNeeded.set(this, async (element, signal) => {
      if (!__classPrivateFieldGet15(this, _LocatorImpl_waitForEnabled, "f")) {
        return;
      }
      await __classPrivateFieldGet15(this, _LocatorImpl_pageOrFrame, "f").waitForFunction((el) => {
        if (["button", "textarea", "input", "select"].includes(el.tagName)) {
          return !el.disabled;
        }
        return true;
      }, {
        timeout: CONDITION_TIMEOUT,
        signal
      }, element);
    });
    _LocatorImpl_waitForStableBoundingBoxIfNeeded.set(this, async (element, signal) => {
      if (!__classPrivateFieldGet15(this, _LocatorImpl_waitForStableBoundingBox, "f")) {
        return;
      }
      function getClientRect() {
        return element.evaluate((el) => {
          return new Promise((resolve) => {
            window.requestAnimationFrame(() => {
              const rect1 = el.getBoundingClientRect();
              window.requestAnimationFrame(() => {
                const rect2 = el.getBoundingClientRect();
                resolve([
                  {
                    x: rect1.x,
                    y: rect1.y,
                    width: rect1.width,
                    height: rect1.height
                  },
                  {
                    x: rect2.x,
                    y: rect2.y,
                    width: rect2.width,
                    height: rect2.height
                  }
                ]);
              });
            });
          });
        });
      }
      await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_waitForFunction).call(this, async () => {
        const [rect1, rect2] = await getClientRect();
        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
      }, signal);
    });
    __classPrivateFieldSet12(this, _LocatorImpl_pageOrFrame, pageOrFrame, "f");
    __classPrivateFieldSet12(this, _LocatorImpl_selector, selector, "f");
  }
  setVisibility(visibility) {
    __classPrivateFieldSet12(this, _LocatorImpl_visibility, visibility, "f");
    return this;
  }
  setTimeout(timeout) {
    __classPrivateFieldSet12(this, _LocatorImpl_timeout, timeout, "f");
    return this;
  }
  setEnsureElementIsInTheViewport(value) {
    __classPrivateFieldSet12(this, _LocatorImpl_ensureElementIsInTheViewport, value, "f");
    return this;
  }
  setWaitForEnabled(value) {
    __classPrivateFieldSet12(this, _LocatorImpl_waitForEnabled, value, "f");
    return this;
  }
  setWaitForStableBoundingBox(value) {
    __classPrivateFieldSet12(this, _LocatorImpl_waitForStableBoundingBox, value, "f");
    return this;
  }
  async click(clickOptions) {
    return await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_run).call(this, async (element) => {
      await element.click(clickOptions);
    }, {
      signal: clickOptions == null ? void 0 : clickOptions.signal,
      conditions: [
        __classPrivateFieldGet15(this, _LocatorImpl_ensureElementIsInTheViewportIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForVisibilityIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForEnabledIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForStableBoundingBoxIfNeeded, "f")
      ]
    });
  }
  async fill(value, fillOptions) {
    return await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_run).call(this, async (element) => {
      const input = element;
      const inputType = await input.evaluate((el) => {
        if (el instanceof HTMLSelectElement) {
          return "select";
        }
        if (el instanceof HTMLInputElement) {
          if ((/* @__PURE__ */ new Set([
            "textarea",
            "text",
            "url",
            "tel",
            "search",
            "password",
            "number",
            "email"
          ])).has(el.type)) {
            return "typeable-input";
          } else {
            return "other-input";
          }
        }
        if (el.isContentEditable) {
          return "contenteditable";
        }
        return "unknown";
      });
      switch (inputType) {
        case "select":
          await input.select(value);
          break;
        case "contenteditable":
        case "typeable-input":
          const textToType = await input.evaluate((input2, newValue) => {
            const currentValue = input2.isContentEditable ? input2.innerText : input2.value;
            if (newValue.length <= currentValue.length || !newValue.startsWith(input2.value)) {
              if (input2.isContentEditable) {
                input2.innerText = "";
              } else {
                input2.value = "";
              }
              return newValue;
            }
            const originalValue = input2.isContentEditable ? input2.innerText : input2.value;
            if (input2.isContentEditable) {
              input2.innerText = "";
              input2.innerText = originalValue;
            } else {
              input2.value = "";
              input2.value = originalValue;
            }
            return newValue.substring(originalValue.length);
          }, value);
          await input.type(textToType);
          break;
        case "other-input":
          await input.focus();
          await input.evaluate((input2, value2) => {
            input2.value = value2;
            input2.dispatchEvent(new Event("input", { bubbles: true }));
            input2.dispatchEvent(new Event("change", { bubbles: true }));
          }, value);
          break;
        case "unknown":
          throw new Error(`Element cannot be filled out.`);
      }
    }, {
      signal: fillOptions == null ? void 0 : fillOptions.signal,
      conditions: [
        __classPrivateFieldGet15(this, _LocatorImpl_ensureElementIsInTheViewportIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForVisibilityIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForEnabledIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForStableBoundingBoxIfNeeded, "f")
      ]
    });
  }
  async hover(hoverOptions) {
    return await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_run).call(this, async (element) => {
      await element.hover();
    }, {
      signal: hoverOptions == null ? void 0 : hoverOptions.signal,
      conditions: [
        __classPrivateFieldGet15(this, _LocatorImpl_ensureElementIsInTheViewportIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForVisibilityIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForStableBoundingBoxIfNeeded, "f")
      ]
    });
  }
  async scroll(scrollOptions) {
    return await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_run).call(this, async (element) => {
      await element.evaluate((el, scrollTop, scrollLeft) => {
        if (scrollTop !== void 0) {
          el.scrollTop = scrollTop;
        }
        if (scrollLeft !== void 0) {
          el.scrollLeft = scrollLeft;
        }
      }, scrollOptions == null ? void 0 : scrollOptions.scrollTop, scrollOptions == null ? void 0 : scrollOptions.scrollLeft);
    }, {
      signal: scrollOptions == null ? void 0 : scrollOptions.signal,
      conditions: [
        __classPrivateFieldGet15(this, _LocatorImpl_ensureElementIsInTheViewportIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForVisibilityIfNeeded, "f"),
        __classPrivateFieldGet15(this, _LocatorImpl_waitForStableBoundingBoxIfNeeded, "f")
      ]
    });
  }
};
_LocatorImpl_pageOrFrame = /* @__PURE__ */ new WeakMap(), _LocatorImpl_selector = /* @__PURE__ */ new WeakMap(), _LocatorImpl_visibility = /* @__PURE__ */ new WeakMap(), _LocatorImpl_timeout = /* @__PURE__ */ new WeakMap(), _LocatorImpl_ensureElementIsInTheViewport = /* @__PURE__ */ new WeakMap(), _LocatorImpl_waitForEnabled = /* @__PURE__ */ new WeakMap(), _LocatorImpl_waitForStableBoundingBox = /* @__PURE__ */ new WeakMap(), _LocatorImpl_ensureElementIsInTheViewportIfNeeded = /* @__PURE__ */ new WeakMap(), _LocatorImpl_waitForVisibilityIfNeeded = /* @__PURE__ */ new WeakMap(), _LocatorImpl_waitForEnabledIfNeeded = /* @__PURE__ */ new WeakMap(), _LocatorImpl_waitForStableBoundingBoxIfNeeded = /* @__PURE__ */ new WeakMap(), _LocatorImpl_instances = /* @__PURE__ */ new WeakSet(), _LocatorImpl_waitForFunction = async function _LocatorImpl_waitForFunction2(fn, signal, timeout = CONDITION_TIMEOUT) {
  let isActive = true;
  let controller;
  const timeoutId = timeout ? setTimeout(() => {
    isActive = false;
    controller == null ? void 0 : controller.abort();
  }, timeout) : 0;
  signal == null ? void 0 : signal.addEventListener("abort", () => {
    controller == null ? void 0 : controller.abort();
    isActive = false;
    clearTimeout(timeoutId);
  }, { once: true });
  while (isActive) {
    controller = new AbortController();
    try {
      const result = await fn(controller.signal);
      if (result) {
        clearTimeout(timeoutId);
        return;
      }
    } catch (err) {
      if (isErrorLike(err)) {
        debugError(err);
        if (err instanceof TimeoutError) {
          continue;
        }
        if (err.name === "AbortError") {
          continue;
        }
      }
      throw err;
    } finally {
      controller.abort();
    }
    await new Promise((resolve) => {
      return setTimeout(resolve, WAIT_FOR_FUNCTION_DELAY);
    });
  }
  signal == null ? void 0 : signal.throwIfAborted();
  throw new TimeoutError(`waitForFunction timed out. The timeout is ${timeout}ms.`);
}, _LocatorImpl_run = async function _LocatorImpl_run2(action, options) {
  await __classPrivateFieldGet15(this, _LocatorImpl_instances, "m", _LocatorImpl_waitForFunction).call(this, async (signal) => {
    const element = await __classPrivateFieldGet15(this, _LocatorImpl_pageOrFrame, "f").waitForSelector(__classPrivateFieldGet15(this, _LocatorImpl_selector, "f"), {
      visible: false,
      timeout: __classPrivateFieldGet15(this, _LocatorImpl_timeout, "f"),
      signal
    });
    if (!element) {
      return false;
    }
    try {
      signal == null ? void 0 : signal.throwIfAborted();
      await Promise.all((options == null ? void 0 : options.conditions.map((check) => {
        return check(element, signal);
      })) || []);
      signal == null ? void 0 : signal.throwIfAborted();
      this.emit(LocatorEmittedEvents.Action);
      await action(element);
      return true;
    } finally {
      void element.dispose().catch(debugError);
    }
  }, options == null ? void 0 : options.signal, __classPrivateFieldGet15(this, _LocatorImpl_timeout, "f"));
};
var RaceLocatorImpl = class extends Locator {
  constructor(locators) {
    super();
    _RaceLocatorImpl_instances.add(this);
    _RaceLocatorImpl_locators.set(this, void 0);
    __classPrivateFieldSet12(this, _RaceLocatorImpl_locators, locators, "f");
  }
  setVisibility(visibility) {
    for (const locator of __classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f")) {
      locator.setVisibility(visibility);
    }
    return this;
  }
  setTimeout(timeout) {
    for (const locator of __classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f")) {
      locator.setTimeout(timeout);
    }
    return this;
  }
  setEnsureElementIsInTheViewport(value) {
    for (const locator of __classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f")) {
      locator.setEnsureElementIsInTheViewport(value);
    }
    return this;
  }
  setWaitForEnabled(value) {
    for (const locator of __classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f")) {
      locator.setWaitForEnabled(value);
    }
    return this;
  }
  setWaitForStableBoundingBox(value) {
    for (const locator of __classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f")) {
      locator.setWaitForStableBoundingBox(value);
    }
    return this;
  }
  async click(clickOptions) {
    return await __classPrivateFieldGet15(this, _RaceLocatorImpl_instances, "m", _RaceLocatorImpl_runRace).call(this, (locator, abortSignal) => {
      return locator.click({
        ...clickOptions,
        signal: abortSignal
      });
    }, {
      signal: clickOptions == null ? void 0 : clickOptions.signal
    });
  }
  async fill(value, fillOptions) {
    return await __classPrivateFieldGet15(this, _RaceLocatorImpl_instances, "m", _RaceLocatorImpl_runRace).call(this, (locator, abortSignal) => {
      return locator.fill(value, {
        ...fillOptions,
        signal: abortSignal
      });
    }, {
      signal: fillOptions == null ? void 0 : fillOptions.signal
    });
  }
  async hover(hoverOptions) {
    return await __classPrivateFieldGet15(this, _RaceLocatorImpl_instances, "m", _RaceLocatorImpl_runRace).call(this, (locator, abortSignal) => {
      return locator.hover({
        ...hoverOptions,
        signal: abortSignal
      });
    }, {
      signal: hoverOptions == null ? void 0 : hoverOptions.signal
    });
  }
  async scroll(scrollOptions) {
    return await __classPrivateFieldGet15(this, _RaceLocatorImpl_instances, "m", _RaceLocatorImpl_runRace).call(this, (locator, abortSignal) => {
      return locator.scroll({
        ...scrollOptions,
        signal: abortSignal
      });
    }, {
      signal: scrollOptions == null ? void 0 : scrollOptions.signal
    });
  }
};
_RaceLocatorImpl_locators = /* @__PURE__ */ new WeakMap(), _RaceLocatorImpl_instances = /* @__PURE__ */ new WeakSet(), _RaceLocatorImpl_runRace = async function _RaceLocatorImpl_runRace2(action, options) {
  var _a2, _b;
  const abortControllers = /* @__PURE__ */ new WeakMap();
  (_a2 = options.signal) == null ? void 0 : _a2.addEventListener("abort", () => {
    var _a3;
    for (const locator of __classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f")) {
      (_a3 = abortControllers.get(locator)) == null ? void 0 : _a3.abort();
    }
  });
  const handleLocatorAction = (locator) => {
    return () => {
      var _a3;
      for (const other of __classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f")) {
        if (other !== locator) {
          (_a3 = abortControllers.get(other)) == null ? void 0 : _a3.abort();
        }
      }
      this.emit(LocatorEmittedEvents.Action);
    };
  };
  const createAbortController = (locator) => {
    const abortController = new AbortController();
    abortControllers.set(locator, abortController);
    return abortController;
  };
  await Promise.allSettled(__classPrivateFieldGet15(this, _RaceLocatorImpl_locators, "f").map((locator) => {
    return action(locator.on(LocatorEmittedEvents.Action, handleLocatorAction(locator)), createAbortController(locator).signal);
  }));
  (_b = options.signal) == null ? void 0 : _b.throwIfAborted();
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js
var __classPrivateFieldGet16 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Page_handlerMap;
var Page = class extends EventEmitter {
  constructor() {
    super();
    _Page_handlerMap.set(this, /* @__PURE__ */ new WeakMap());
  }
  isServiceWorkerBypassed() {
    throw new Error("Not implemented");
  }
  isDragInterceptionEnabled() {
    throw new Error("Not implemented");
  }
  isJavaScriptEnabled() {
    throw new Error("Not implemented");
  }
  on(eventName, handler) {
    if (eventName === "request") {
      const wrap = __classPrivateFieldGet16(this, _Page_handlerMap, "f").get(handler) || ((event) => {
        event.enqueueInterceptAction(() => {
          return handler(event);
        });
      });
      __classPrivateFieldGet16(this, _Page_handlerMap, "f").set(handler, wrap);
      return super.on(eventName, wrap);
    }
    return super.on(eventName, handler);
  }
  once(eventName, handler) {
    return super.once(eventName, handler);
  }
  off(eventName, handler) {
    if (eventName === "request") {
      handler = __classPrivateFieldGet16(this, _Page_handlerMap, "f").get(handler) || handler;
    }
    return super.off(eventName, handler);
  }
  waitForFileChooser() {
    throw new Error("Not implemented");
  }
  async setGeolocation() {
    throw new Error("Not implemented");
  }
  target() {
    throw new Error("Not implemented");
  }
  browser() {
    throw new Error("Not implemented");
  }
  browserContext() {
    throw new Error("Not implemented");
  }
  mainFrame() {
    throw new Error("Not implemented");
  }
  get keyboard() {
    throw new Error("Not implemented");
  }
  get touchscreen() {
    throw new Error("Not implemented");
  }
  get coverage() {
    throw new Error("Not implemented");
  }
  get tracing() {
    throw new Error("Not implemented");
  }
  get accessibility() {
    throw new Error("Not implemented");
  }
  frames() {
    throw new Error("Not implemented");
  }
  workers() {
    throw new Error("Not implemented");
  }
  async setRequestInterception() {
    throw new Error("Not implemented");
  }
  async setBypassServiceWorker() {
    throw new Error("Not implemented");
  }
  async setDragInterception() {
    throw new Error("Not implemented");
  }
  setOfflineMode() {
    throw new Error("Not implemented");
  }
  emulateNetworkConditions() {
    throw new Error("Not implemented");
  }
  setDefaultNavigationTimeout() {
    throw new Error("Not implemented");
  }
  setDefaultTimeout() {
    throw new Error("Not implemented");
  }
  getDefaultTimeout() {
    throw new Error("Not implemented");
  }
  locator(selector) {
    return Locator.create(this, selector);
  }
  async $(selector) {
    return this.mainFrame().$(selector);
  }
  async $$(selector) {
    return this.mainFrame().$$(selector);
  }
  async evaluateHandle() {
    throw new Error("Not implemented");
  }
  async queryObjects() {
    throw new Error("Not implemented");
  }
  async $eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
    return this.mainFrame().$eval(selector, pageFunction, ...args);
  }
  async $$eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
    return this.mainFrame().$$eval(selector, pageFunction, ...args);
  }
  async $x(expression) {
    return this.mainFrame().$x(expression);
  }
  async cookies() {
    throw new Error("Not implemented");
  }
  async deleteCookie() {
    throw new Error("Not implemented");
  }
  async setCookie() {
    throw new Error("Not implemented");
  }
  async addScriptTag() {
    throw new Error("Not implemented");
  }
  async addStyleTag() {
    throw new Error("Not implemented");
  }
  async exposeFunction() {
    throw new Error("Not implemented");
  }
  async removeExposedFunction() {
    throw new Error("Not implemented");
  }
  async authenticate() {
    throw new Error("Not implemented");
  }
  async setExtraHTTPHeaders() {
    throw new Error("Not implemented");
  }
  async setUserAgent() {
    throw new Error("Not implemented");
  }
  async metrics() {
    throw new Error("Not implemented");
  }
  url() {
    throw new Error("Not implemented");
  }
  async content() {
    throw new Error("Not implemented");
  }
  async setContent() {
    throw new Error("Not implemented");
  }
  async goto() {
    throw new Error("Not implemented");
  }
  async reload() {
    throw new Error("Not implemented");
  }
  async waitForNavigation() {
    throw new Error("Not implemented");
  }
  async waitForRequest() {
    throw new Error("Not implemented");
  }
  async waitForResponse() {
    throw new Error("Not implemented");
  }
  async waitForNetworkIdle() {
    throw new Error("Not implemented");
  }
  async _waitForNetworkIdle(networkManager, idleTime, timeout, closedDeferred) {
    const idleDeferred = Deferred.create();
    const abortDeferred = Deferred.create();
    let idleTimer;
    const cleanup = () => {
      clearTimeout(idleTimer);
      abortDeferred.reject(new Error("abort"));
    };
    const evaluate = () => {
      clearTimeout(idleTimer);
      if (networkManager.inFlightRequestsCount() === 0) {
        idleTimer = setTimeout(() => {
          return idleDeferred.resolve();
        }, idleTime);
      }
    };
    const listenToEvent = (event) => {
      return waitForEvent(networkManager, event, () => {
        evaluate();
        return false;
      }, timeout, abortDeferred);
    };
    const eventPromises = [
      listenToEvent(NetworkManagerEmittedEvents.Request),
      listenToEvent(NetworkManagerEmittedEvents.Response),
      listenToEvent(NetworkManagerEmittedEvents.RequestFailed)
    ];
    evaluate();
    const closedPromise = closedDeferred.valueOrThrow();
    await Deferred.race([idleDeferred, ...eventPromises, closedPromise]).then((r) => {
      cleanup();
      return r;
    }, (error) => {
      cleanup();
      throw error;
    });
  }
  async waitForFrame() {
    throw new Error("Not implemented");
  }
  async goBack() {
    throw new Error("Not implemented");
  }
  async goForward() {
    throw new Error("Not implemented");
  }
  async bringToFront() {
    throw new Error("Not implemented");
  }
  async emulate(device) {
    await Promise.all([
      this.setUserAgent(device.userAgent),
      this.setViewport(device.viewport)
    ]);
  }
  async setJavaScriptEnabled() {
    throw new Error("Not implemented");
  }
  async setBypassCSP() {
    throw new Error("Not implemented");
  }
  async emulateMediaType() {
    throw new Error("Not implemented");
  }
  async emulateCPUThrottling() {
    throw new Error("Not implemented");
  }
  async emulateMediaFeatures() {
    throw new Error("Not implemented");
  }
  async emulateTimezone() {
    throw new Error("Not implemented");
  }
  async emulateIdleState() {
    throw new Error("Not implemented");
  }
  async emulateVisionDeficiency() {
    throw new Error("Not implemented");
  }
  async setViewport() {
    throw new Error("Not implemented");
  }
  viewport() {
    throw new Error("Not implemented");
  }
  async evaluate() {
    throw new Error("Not implemented");
  }
  async evaluateOnNewDocument() {
    throw new Error("Not implemented");
  }
  async removeScriptToEvaluateOnNewDocument() {
    throw new Error("Not implemented");
  }
  async setCacheEnabled() {
    throw new Error("Not implemented");
  }
  async _maybeWriteBufferToFile(path, buffer) {
    if (!path) {
      return;
    }
    const fs2 = await importFSPromises();
    await fs2.writeFile(path, buffer);
  }
  async screenshot() {
    throw new Error("Not implemented");
  }
  _getPDFOptions(options = {}, lengthUnit = "in") {
    var _a2, _b, _c, _d, _e, _f;
    const defaults = {
      scale: 1,
      displayHeaderFooter: false,
      headerTemplate: "",
      footerTemplate: "",
      printBackground: false,
      landscape: false,
      pageRanges: "",
      preferCSSPageSize: false,
      omitBackground: false,
      timeout: 3e4
    };
    let width = 8.5;
    let height = 11;
    if (options.format) {
      const format = paperFormats[options.format.toLowerCase()];
      assert(format, "Unknown paper format: " + options.format);
      width = format.width;
      height = format.height;
    } else {
      width = (_a2 = convertPrintParameterToInches(options.width, lengthUnit)) != null ? _a2 : width;
      height = (_b = convertPrintParameterToInches(options.height, lengthUnit)) != null ? _b : height;
    }
    const margin = {
      top: convertPrintParameterToInches((_c = options.margin) == null ? void 0 : _c.top, lengthUnit) || 0,
      left: convertPrintParameterToInches((_d = options.margin) == null ? void 0 : _d.left, lengthUnit) || 0,
      bottom: convertPrintParameterToInches((_e = options.margin) == null ? void 0 : _e.bottom, lengthUnit) || 0,
      right: convertPrintParameterToInches((_f = options.margin) == null ? void 0 : _f.right, lengthUnit) || 0
    };
    const output = {
      ...defaults,
      ...options,
      width,
      height,
      margin
    };
    return output;
  }
  async createPDFStream() {
    throw new Error("Not implemented");
  }
  async pdf() {
    throw new Error("Not implemented");
  }
  async title() {
    throw new Error("Not implemented");
  }
  async close() {
    throw new Error("Not implemented");
  }
  isClosed() {
    throw new Error("Not implemented");
  }
  get mouse() {
    throw new Error("Not implemented");
  }
  click(selector, options) {
    return this.mainFrame().click(selector, options);
  }
  focus(selector) {
    return this.mainFrame().focus(selector);
  }
  hover(selector) {
    return this.mainFrame().hover(selector);
  }
  select(selector, ...values) {
    return this.mainFrame().select(selector, ...values);
  }
  tap(selector) {
    return this.mainFrame().tap(selector);
  }
  type(selector, text, options) {
    return this.mainFrame().type(selector, text, options);
  }
  waitForTimeout(milliseconds) {
    return this.mainFrame().waitForTimeout(milliseconds);
  }
  async waitForSelector(selector, options = {}) {
    return await this.mainFrame().waitForSelector(selector, options);
  }
  waitForXPath() {
    throw new Error("Not implemented");
  }
  waitForFunction(pageFunction, options, ...args) {
    return this.mainFrame().waitForFunction(pageFunction, options, ...args);
  }
  waitForDevicePrompt() {
    throw new Error("Not implemented");
  }
};
_Page_handlerMap = /* @__PURE__ */ new WeakMap();
var supportedMetrics = /* @__PURE__ */ new Set([
  "Timestamp",
  "Documents",
  "Frames",
  "JSEventListeners",
  "Nodes",
  "LayoutCount",
  "RecalcStyleCount",
  "LayoutDuration",
  "RecalcStyleDuration",
  "ScriptDuration",
  "TaskDuration",
  "JSHeapUsedSize",
  "JSHeapTotalSize"
]);
var unitToPixels = {
  px: 1,
  in: 96,
  cm: 37.8,
  mm: 3.78
};
function convertPrintParameterToInches(parameter, lengthUnit = "in") {
  if (typeof parameter === "undefined") {
    return void 0;
  }
  let pixels;
  if (isNumber(parameter)) {
    pixels = parameter;
  } else if (isString(parameter)) {
    const text = parameter;
    let unit = text.substring(text.length - 2).toLowerCase();
    let valueText = "";
    if (unit in unitToPixels) {
      valueText = text.substring(0, text.length - 2);
    } else {
      unit = "px";
      valueText = text;
    }
    const value = Number(valueText);
    assert(!isNaN(value), "Failed to parse parameter value: " + text);
    pixels = value * unitToPixels[unit];
  } else {
    throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
  }
  return pixels / unitToPixels[lengthUnit];
}

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js
var Keyboard = class {
  constructor() {
  }
  async down() {
    throw new Error("Not implemented");
  }
  async up() {
    throw new Error("Not implemented");
  }
  async sendCharacter() {
    throw new Error("Not implemented");
  }
  async type() {
    throw new Error("Not implemented");
  }
  async press() {
    throw new Error("Not implemented");
  }
};
var MouseButton = Object.freeze({
  Left: "left",
  Right: "right",
  Middle: "middle",
  Back: "back",
  Forward: "forward"
});
var Mouse = class {
  constructor() {
  }
  async reset() {
    throw new Error("Not implemented");
  }
  async move() {
    throw new Error("Not implemented");
  }
  async down() {
    throw new Error("Not implemented");
  }
  async up() {
    throw new Error("Not implemented");
  }
  async click() {
    throw new Error("Not implemented");
  }
  async wheel() {
    throw new Error("Not implemented");
  }
  async drag() {
    throw new Error("Not implemented");
  }
  async dragEnter() {
    throw new Error("Not implemented");
  }
  async dragOver() {
    throw new Error("Not implemented");
  }
  async drop() {
    throw new Error("Not implemented");
  }
  async dragAndDrop() {
    throw new Error("Not implemented");
  }
};
var Touchscreen = class {
  constructor() {
  }
  async tap() {
    throw new Error("Not implemented");
  }
  async touchStart() {
    throw new Error("Not implemented");
  }
  async touchMove() {
    throw new Error("Not implemented");
  }
  async touchEnd() {
    throw new Error("Not implemented");
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js
var Frame = class {
  constructor() {
    this._hasStartedLoading = false;
  }
  page() {
    throw new Error("Not implemented");
  }
  isOOPFrame() {
    throw new Error("Not implemented");
  }
  async goto() {
    throw new Error("Not implemented");
  }
  async waitForNavigation() {
    throw new Error("Not implemented");
  }
  _client() {
    throw new Error("Not implemented");
  }
  executionContext() {
    throw new Error("Not implemented");
  }
  mainRealm() {
    throw new Error("Not implemented");
  }
  isolatedRealm() {
    throw new Error("Not implemented");
  }
  async evaluateHandle() {
    throw new Error("Not implemented");
  }
  async evaluate() {
    throw new Error("Not implemented");
  }
  locator(selector) {
    return Locator.create(this, selector);
  }
  async $() {
    throw new Error("Not implemented");
  }
  async $$() {
    throw new Error("Not implemented");
  }
  async $eval() {
    throw new Error("Not implemented");
  }
  async $$eval() {
    throw new Error("Not implemented");
  }
  async $x() {
    throw new Error("Not implemented");
  }
  async waitForSelector(selector, options = {}) {
    const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
    return await QueryHandler2.waitFor(this, updatedSelector, options);
  }
  async waitForXPath(xpath, options = {}) {
    if (xpath.startsWith("//")) {
      xpath = `.${xpath}`;
    }
    return this.waitForSelector(`xpath/${xpath}`, options);
  }
  waitForFunction(pageFunction, options = {}, ...args) {
    return this.mainRealm().waitForFunction(pageFunction, options, ...args);
  }
  async content() {
    throw new Error("Not implemented");
  }
  async setContent() {
    throw new Error("Not implemented");
  }
  name() {
    return this._name || "";
  }
  url() {
    throw new Error("Not implemented");
  }
  parentFrame() {
    throw new Error("Not implemented");
  }
  childFrames() {
    throw new Error("Not implemented");
  }
  isDetached() {
    throw new Error("Not implemented");
  }
  async addScriptTag() {
    throw new Error("Not implemented");
  }
  async addStyleTag() {
    throw new Error("Not implemented");
  }
  click(selector, options = {}) {
    return this.isolatedRealm().click(selector, options);
  }
  async focus(selector) {
    return this.isolatedRealm().focus(selector);
  }
  hover(selector) {
    return this.isolatedRealm().hover(selector);
  }
  select(selector, ...values) {
    return this.isolatedRealm().select(selector, ...values);
  }
  tap(selector) {
    return this.isolatedRealm().tap(selector);
  }
  type(selector, text, options) {
    return this.isolatedRealm().type(selector, text, options);
  }
  waitForTimeout(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  }
  async title() {
    throw new Error("Not implemented");
  }
  waitForDevicePrompt() {
    throw new Error("Not implemented");
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Accessibility.js
var __classPrivateFieldSet13 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet17 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Accessibility_client;
var _AXNode_instances;
var _AXNode_richlyEditable;
var _AXNode_editable;
var _AXNode_focusable;
var _AXNode_hidden;
var _AXNode_name;
var _AXNode_role;
var _AXNode_ignored;
var _AXNode_cachedHasFocusableChild;
var _AXNode_isPlainTextField;
var _AXNode_isTextOnlyObject;
var _AXNode_hasFocusableChild;
var Accessibility = class {
  constructor(client) {
    _Accessibility_client.set(this, void 0);
    __classPrivateFieldSet13(this, _Accessibility_client, client, "f");
  }
  async snapshot(options = {}) {
    var _a2, _b;
    const { interestingOnly = true, root = null } = options;
    const { nodes } = await __classPrivateFieldGet17(this, _Accessibility_client, "f").send("Accessibility.getFullAXTree");
    let backendNodeId;
    if (root) {
      const { node } = await __classPrivateFieldGet17(this, _Accessibility_client, "f").send("DOM.describeNode", {
        objectId: root.id
      });
      backendNodeId = node.backendNodeId;
    }
    const defaultRoot = AXNode.createTree(nodes);
    let needle = defaultRoot;
    if (backendNodeId) {
      needle = defaultRoot.find((node) => {
        return node.payload.backendDOMNodeId === backendNodeId;
      });
      if (!needle) {
        return null;
      }
    }
    if (!interestingOnly) {
      return (_a2 = this.serializeTree(needle)[0]) != null ? _a2 : null;
    }
    const interestingNodes = /* @__PURE__ */ new Set();
    this.collectInterestingNodes(interestingNodes, defaultRoot, false);
    if (!interestingNodes.has(needle)) {
      return null;
    }
    return (_b = this.serializeTree(needle, interestingNodes)[0]) != null ? _b : null;
  }
  serializeTree(node, interestingNodes) {
    const children = [];
    for (const child of node.children) {
      children.push(...this.serializeTree(child, interestingNodes));
    }
    if (interestingNodes && !interestingNodes.has(node)) {
      return children;
    }
    const serializedNode = node.serialize();
    if (children.length) {
      serializedNode.children = children;
    }
    return [serializedNode];
  }
  collectInterestingNodes(collection, node, insideControl) {
    if (node.isInteresting(insideControl)) {
      collection.add(node);
    }
    if (node.isLeafNode()) {
      return;
    }
    insideControl = insideControl || node.isControl();
    for (const child of node.children) {
      this.collectInterestingNodes(collection, child, insideControl);
    }
  }
};
_Accessibility_client = /* @__PURE__ */ new WeakMap();
var AXNode = class {
  constructor(payload) {
    _AXNode_instances.add(this);
    this.children = [];
    _AXNode_richlyEditable.set(this, false);
    _AXNode_editable.set(this, false);
    _AXNode_focusable.set(this, false);
    _AXNode_hidden.set(this, false);
    _AXNode_name.set(this, void 0);
    _AXNode_role.set(this, void 0);
    _AXNode_ignored.set(this, void 0);
    _AXNode_cachedHasFocusableChild.set(this, void 0);
    this.payload = payload;
    __classPrivateFieldSet13(this, _AXNode_name, this.payload.name ? this.payload.name.value : "", "f");
    __classPrivateFieldSet13(this, _AXNode_role, this.payload.role ? this.payload.role.value : "Unknown", "f");
    __classPrivateFieldSet13(this, _AXNode_ignored, this.payload.ignored, "f");
    for (const property of this.payload.properties || []) {
      if (property.name === "editable") {
        __classPrivateFieldSet13(this, _AXNode_richlyEditable, property.value.value === "richtext", "f");
        __classPrivateFieldSet13(this, _AXNode_editable, true, "f");
      }
      if (property.name === "focusable") {
        __classPrivateFieldSet13(this, _AXNode_focusable, property.value.value, "f");
      }
      if (property.name === "hidden") {
        __classPrivateFieldSet13(this, _AXNode_hidden, property.value.value, "f");
      }
    }
  }
  find(predicate) {
    if (predicate(this)) {
      return this;
    }
    for (const child of this.children) {
      const result = child.find(predicate);
      if (result) {
        return result;
      }
    }
    return null;
  }
  isLeafNode() {
    if (!this.children.length) {
      return true;
    }
    if (__classPrivateFieldGet17(this, _AXNode_instances, "m", _AXNode_isPlainTextField).call(this) || __classPrivateFieldGet17(this, _AXNode_instances, "m", _AXNode_isTextOnlyObject).call(this)) {
      return true;
    }
    switch (__classPrivateFieldGet17(this, _AXNode_role, "f")) {
      case "doc-cover":
      case "graphics-symbol":
      case "img":
      case "Meter":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
      default:
        break;
    }
    if (__classPrivateFieldGet17(this, _AXNode_instances, "m", _AXNode_hasFocusableChild).call(this)) {
      return false;
    }
    if (__classPrivateFieldGet17(this, _AXNode_focusable, "f") && __classPrivateFieldGet17(this, _AXNode_name, "f")) {
      return true;
    }
    if (__classPrivateFieldGet17(this, _AXNode_role, "f") === "heading" && __classPrivateFieldGet17(this, _AXNode_name, "f")) {
      return true;
    }
    return false;
  }
  isControl() {
    switch (__classPrivateFieldGet17(this, _AXNode_role, "f")) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "tree":
      case "treeitem":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    const role = __classPrivateFieldGet17(this, _AXNode_role, "f");
    if (role === "Ignored" || __classPrivateFieldGet17(this, _AXNode_hidden, "f") || __classPrivateFieldGet17(this, _AXNode_ignored, "f")) {
      return false;
    }
    if (__classPrivateFieldGet17(this, _AXNode_focusable, "f") || __classPrivateFieldGet17(this, _AXNode_richlyEditable, "f")) {
      return true;
    }
    if (this.isControl()) {
      return true;
    }
    if (insideControl) {
      return false;
    }
    return this.isLeafNode() && !!__classPrivateFieldGet17(this, _AXNode_name, "f");
  }
  serialize() {
    const properties = /* @__PURE__ */ new Map();
    for (const property of this.payload.properties || []) {
      properties.set(property.name.toLowerCase(), property.value.value);
    }
    if (this.payload.name) {
      properties.set("name", this.payload.name.value);
    }
    if (this.payload.value) {
      properties.set("value", this.payload.value.value);
    }
    if (this.payload.description) {
      properties.set("description", this.payload.description.value);
    }
    const node = {
      role: __classPrivateFieldGet17(this, _AXNode_role, "f")
    };
    const userStringProperties = [
      "name",
      "value",
      "description",
      "keyshortcuts",
      "roledescription",
      "valuetext"
    ];
    const getUserStringPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const userStringProperty of userStringProperties) {
      if (!properties.has(userStringProperty)) {
        continue;
      }
      node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    const getBooleanPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && __classPrivateFieldGet17(this, _AXNode_role, "f") === "RootWebArea") {
        continue;
      }
      const value = getBooleanPropertyValue(booleanProperty);
      if (!value) {
        continue;
      }
      node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
    }
    const tristateProperties = ["checked", "pressed"];
    for (const tristateProperty of tristateProperties) {
      if (!properties.has(tristateProperty)) {
        continue;
      }
      const value = properties.get(tristateProperty);
      node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    const getNumericalPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const numericalProperty of numericalProperties) {
      if (!properties.has(numericalProperty)) {
        continue;
      }
      node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid",
      "orientation"
    ];
    const getTokenPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const tokenProperty of tokenProperties) {
      const value = getTokenPropertyValue(tokenProperty);
      if (!value || value === "false") {
        continue;
      }
      node[tokenProperty] = getTokenPropertyValue(tokenProperty);
    }
    return node;
  }
  static createTree(payloads) {
    const nodeById = /* @__PURE__ */ new Map();
    for (const payload of payloads) {
      nodeById.set(payload.nodeId, new AXNode(payload));
    }
    for (const node of nodeById.values()) {
      for (const childId of node.payload.childIds || []) {
        const child = nodeById.get(childId);
        if (child) {
          node.children.push(child);
        }
      }
    }
    return nodeById.values().next().value;
  }
};
_AXNode_richlyEditable = /* @__PURE__ */ new WeakMap(), _AXNode_editable = /* @__PURE__ */ new WeakMap(), _AXNode_focusable = /* @__PURE__ */ new WeakMap(), _AXNode_hidden = /* @__PURE__ */ new WeakMap(), _AXNode_name = /* @__PURE__ */ new WeakMap(), _AXNode_role = /* @__PURE__ */ new WeakMap(), _AXNode_ignored = /* @__PURE__ */ new WeakMap(), _AXNode_cachedHasFocusableChild = /* @__PURE__ */ new WeakMap(), _AXNode_instances = /* @__PURE__ */ new WeakSet(), _AXNode_isPlainTextField = function _AXNode_isPlainTextField2() {
  if (__classPrivateFieldGet17(this, _AXNode_richlyEditable, "f")) {
    return false;
  }
  if (__classPrivateFieldGet17(this, _AXNode_editable, "f")) {
    return true;
  }
  return __classPrivateFieldGet17(this, _AXNode_role, "f") === "textbox" || __classPrivateFieldGet17(this, _AXNode_role, "f") === "searchbox";
}, _AXNode_isTextOnlyObject = function _AXNode_isTextOnlyObject2() {
  const role = __classPrivateFieldGet17(this, _AXNode_role, "f");
  return role === "LineBreak" || role === "text" || role === "InlineTextBox";
}, _AXNode_hasFocusableChild = function _AXNode_hasFocusableChild2() {
  if (__classPrivateFieldGet17(this, _AXNode_cachedHasFocusableChild, "f") === void 0) {
    __classPrivateFieldSet13(this, _AXNode_cachedHasFocusableChild, false, "f");
    for (const child of this.children) {
      if (__classPrivateFieldGet17(child, _AXNode_focusable, "f") || __classPrivateFieldGet17(child, _AXNode_instances, "m", _AXNode_hasFocusableChild2).call(child)) {
        __classPrivateFieldSet13(this, _AXNode_cachedHasFocusableChild, true, "f");
        break;
      }
    }
  }
  return __classPrivateFieldGet17(this, _AXNode_cachedHasFocusableChild, "f");
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js
var __classPrivateFieldSet14 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet18 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Callback_id;
var _Callback_error;
var _Callback_deferred;
var _Callback_timer;
var _Callback_label;
var _CallbackRegistry_callbacks;
var _CallbackRegistry_idGenerator;
var _Connection_instances;
var _Connection_url;
var _Connection_transport;
var _Connection_delay;
var _Connection_timeout;
var _Connection_sessions;
var _Connection_closed;
var _Connection_manuallyAttached;
var _Connection_callbacks;
var _Connection_onClose;
var _CDPSessionImpl_sessionId;
var _CDPSessionImpl_targetType;
var _CDPSessionImpl_callbacks;
var _CDPSessionImpl_connection;
var debugProtocolSend = debug("puppeteer:protocol:SEND \u25BA");
var debugProtocolReceive = debug("puppeteer:protocol:RECV \u25C0");
var ConnectionEmittedEvents = {
  Disconnected: Symbol("Connection.Disconnected")
};
function createIncrementalIdGenerator() {
  let id = 0;
  return () => {
    return ++id;
  };
}
var Callback = class {
  constructor(id, label, timeout) {
    _Callback_id.set(this, void 0);
    _Callback_error.set(this, new ProtocolError());
    _Callback_deferred.set(this, Deferred.create());
    _Callback_timer.set(this, void 0);
    _Callback_label.set(this, void 0);
    __classPrivateFieldSet14(this, _Callback_id, id, "f");
    __classPrivateFieldSet14(this, _Callback_label, label, "f");
    if (timeout) {
      __classPrivateFieldSet14(this, _Callback_timer, setTimeout(() => {
        __classPrivateFieldGet18(this, _Callback_deferred, "f").reject(rewriteError(__classPrivateFieldGet18(this, _Callback_error, "f"), `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
      }, timeout), "f");
    }
  }
  resolve(value) {
    clearTimeout(__classPrivateFieldGet18(this, _Callback_timer, "f"));
    __classPrivateFieldGet18(this, _Callback_deferred, "f").resolve(value);
  }
  reject(error) {
    clearTimeout(__classPrivateFieldGet18(this, _Callback_timer, "f"));
    __classPrivateFieldGet18(this, _Callback_deferred, "f").reject(error);
  }
  get id() {
    return __classPrivateFieldGet18(this, _Callback_id, "f");
  }
  get promise() {
    return __classPrivateFieldGet18(this, _Callback_deferred, "f");
  }
  get error() {
    return __classPrivateFieldGet18(this, _Callback_error, "f");
  }
  get label() {
    return __classPrivateFieldGet18(this, _Callback_label, "f");
  }
};
_Callback_id = /* @__PURE__ */ new WeakMap(), _Callback_error = /* @__PURE__ */ new WeakMap(), _Callback_deferred = /* @__PURE__ */ new WeakMap(), _Callback_timer = /* @__PURE__ */ new WeakMap(), _Callback_label = /* @__PURE__ */ new WeakMap();
var CallbackRegistry = class {
  constructor() {
    _CallbackRegistry_callbacks.set(this, /* @__PURE__ */ new Map());
    _CallbackRegistry_idGenerator.set(this, createIncrementalIdGenerator());
  }
  create(label, timeout, request) {
    const callback = new Callback(__classPrivateFieldGet18(this, _CallbackRegistry_idGenerator, "f").call(this), label, timeout);
    __classPrivateFieldGet18(this, _CallbackRegistry_callbacks, "f").set(callback.id, callback);
    try {
      request(callback.id);
    } catch (error) {
      callback.promise.valueOrThrow().catch(debugError).finally(() => {
        __classPrivateFieldGet18(this, _CallbackRegistry_callbacks, "f").delete(callback.id);
      });
      callback.reject(error);
      throw error;
    }
    return callback.promise.valueOrThrow().finally(() => {
      __classPrivateFieldGet18(this, _CallbackRegistry_callbacks, "f").delete(callback.id);
    });
  }
  reject(id, message, originalMessage) {
    const callback = __classPrivateFieldGet18(this, _CallbackRegistry_callbacks, "f").get(id);
    if (!callback) {
      return;
    }
    this._reject(callback, message, originalMessage);
  }
  _reject(callback, errorMessage, originalMessage) {
    const isError = errorMessage instanceof ProtocolError;
    const message = isError ? errorMessage.message : errorMessage;
    const error = isError ? errorMessage : callback.error;
    callback.reject(rewriteError(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
  }
  resolve(id, value) {
    const callback = __classPrivateFieldGet18(this, _CallbackRegistry_callbacks, "f").get(id);
    if (!callback) {
      return;
    }
    callback.resolve(value);
  }
  clear() {
    for (const callback of __classPrivateFieldGet18(this, _CallbackRegistry_callbacks, "f").values()) {
      this._reject(callback, new TargetCloseError("Target closed"));
    }
    __classPrivateFieldGet18(this, _CallbackRegistry_callbacks, "f").clear();
  }
};
_CallbackRegistry_callbacks = /* @__PURE__ */ new WeakMap(), _CallbackRegistry_idGenerator = /* @__PURE__ */ new WeakMap();
var Connection = class extends EventEmitter {
  constructor(url, transport, delay = 0, timeout) {
    super();
    _Connection_instances.add(this);
    _Connection_url.set(this, void 0);
    _Connection_transport.set(this, void 0);
    _Connection_delay.set(this, void 0);
    _Connection_timeout.set(this, void 0);
    _Connection_sessions.set(this, /* @__PURE__ */ new Map());
    _Connection_closed.set(this, false);
    _Connection_manuallyAttached.set(this, /* @__PURE__ */ new Set());
    _Connection_callbacks.set(this, new CallbackRegistry());
    __classPrivateFieldSet14(this, _Connection_url, url, "f");
    __classPrivateFieldSet14(this, _Connection_delay, delay, "f");
    __classPrivateFieldSet14(this, _Connection_timeout, timeout != null ? timeout : 18e4, "f");
    __classPrivateFieldSet14(this, _Connection_transport, transport, "f");
    __classPrivateFieldGet18(this, _Connection_transport, "f").onmessage = this.onMessage.bind(this);
    __classPrivateFieldGet18(this, _Connection_transport, "f").onclose = __classPrivateFieldGet18(this, _Connection_instances, "m", _Connection_onClose).bind(this);
  }
  static fromSession(session) {
    return session.connection();
  }
  get timeout() {
    return __classPrivateFieldGet18(this, _Connection_timeout, "f");
  }
  get _closed() {
    return __classPrivateFieldGet18(this, _Connection_closed, "f");
  }
  get _sessions() {
    return __classPrivateFieldGet18(this, _Connection_sessions, "f");
  }
  session(sessionId) {
    return __classPrivateFieldGet18(this, _Connection_sessions, "f").get(sessionId) || null;
  }
  url() {
    return __classPrivateFieldGet18(this, _Connection_url, "f");
  }
  send(method, ...paramArgs) {
    const params = paramArgs.length ? paramArgs[0] : void 0;
    return this._rawSend(__classPrivateFieldGet18(this, _Connection_callbacks, "f"), method, params);
  }
  _rawSend(callbacks, method, params, sessionId) {
    return callbacks.create(method, __classPrivateFieldGet18(this, _Connection_timeout, "f"), (id) => {
      const stringifiedMessage = JSON.stringify({
        method,
        params,
        id,
        sessionId
      });
      debugProtocolSend(stringifiedMessage);
      __classPrivateFieldGet18(this, _Connection_transport, "f").send(stringifiedMessage);
    });
  }
  async closeBrowser() {
    await this.send("Browser.close");
  }
  async onMessage(message) {
    if (__classPrivateFieldGet18(this, _Connection_delay, "f")) {
      await new Promise((f) => {
        return setTimeout(f, __classPrivateFieldGet18(this, _Connection_delay, "f"));
      });
    }
    debugProtocolReceive(message);
    const object = JSON.parse(message);
    if (object.method === "Target.attachedToTarget") {
      const sessionId = object.params.sessionId;
      const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId);
      __classPrivateFieldGet18(this, _Connection_sessions, "f").set(sessionId, session);
      this.emit("sessionattached", session);
      const parentSession = __classPrivateFieldGet18(this, _Connection_sessions, "f").get(object.sessionId);
      if (parentSession) {
        parentSession.emit("sessionattached", session);
      }
    } else if (object.method === "Target.detachedFromTarget") {
      const session = __classPrivateFieldGet18(this, _Connection_sessions, "f").get(object.params.sessionId);
      if (session) {
        session._onClosed();
        __classPrivateFieldGet18(this, _Connection_sessions, "f").delete(object.params.sessionId);
        this.emit("sessiondetached", session);
        const parentSession = __classPrivateFieldGet18(this, _Connection_sessions, "f").get(object.sessionId);
        if (parentSession) {
          parentSession.emit("sessiondetached", session);
        }
      }
    }
    if (object.sessionId) {
      const session = __classPrivateFieldGet18(this, _Connection_sessions, "f").get(object.sessionId);
      if (session) {
        session._onMessage(object);
      }
    } else if (object.id) {
      if (object.error) {
        __classPrivateFieldGet18(this, _Connection_callbacks, "f").reject(object.id, createProtocolErrorMessage(object), object.error.message);
      } else {
        __classPrivateFieldGet18(this, _Connection_callbacks, "f").resolve(object.id, object.result);
      }
    } else {
      this.emit(object.method, object.params);
    }
  }
  dispose() {
    __classPrivateFieldGet18(this, _Connection_instances, "m", _Connection_onClose).call(this);
    __classPrivateFieldGet18(this, _Connection_transport, "f").close();
  }
  isAutoAttached(targetId) {
    return !__classPrivateFieldGet18(this, _Connection_manuallyAttached, "f").has(targetId);
  }
  async _createSession(targetInfo, isAutoAttachEmulated = true) {
    if (!isAutoAttachEmulated) {
      __classPrivateFieldGet18(this, _Connection_manuallyAttached, "f").add(targetInfo.targetId);
    }
    const { sessionId } = await this.send("Target.attachToTarget", {
      targetId: targetInfo.targetId,
      flatten: true
    });
    __classPrivateFieldGet18(this, _Connection_manuallyAttached, "f").delete(targetInfo.targetId);
    const session = __classPrivateFieldGet18(this, _Connection_sessions, "f").get(sessionId);
    if (!session) {
      throw new Error("CDPSession creation failed.");
    }
    return session;
  }
  async createSession(targetInfo) {
    return await this._createSession(targetInfo, false);
  }
};
_Connection_url = /* @__PURE__ */ new WeakMap(), _Connection_transport = /* @__PURE__ */ new WeakMap(), _Connection_delay = /* @__PURE__ */ new WeakMap(), _Connection_timeout = /* @__PURE__ */ new WeakMap(), _Connection_sessions = /* @__PURE__ */ new WeakMap(), _Connection_closed = /* @__PURE__ */ new WeakMap(), _Connection_manuallyAttached = /* @__PURE__ */ new WeakMap(), _Connection_callbacks = /* @__PURE__ */ new WeakMap(), _Connection_instances = /* @__PURE__ */ new WeakSet(), _Connection_onClose = function _Connection_onClose2() {
  if (__classPrivateFieldGet18(this, _Connection_closed, "f")) {
    return;
  }
  __classPrivateFieldSet14(this, _Connection_closed, true, "f");
  __classPrivateFieldGet18(this, _Connection_transport, "f").onmessage = void 0;
  __classPrivateFieldGet18(this, _Connection_transport, "f").onclose = void 0;
  __classPrivateFieldGet18(this, _Connection_callbacks, "f").clear();
  for (const session of __classPrivateFieldGet18(this, _Connection_sessions, "f").values()) {
    session._onClosed();
  }
  __classPrivateFieldGet18(this, _Connection_sessions, "f").clear();
  this.emit(ConnectionEmittedEvents.Disconnected);
};
var CDPSessionEmittedEvents = {
  Disconnected: Symbol("CDPSession.Disconnected")
};
var CDPSession = class extends EventEmitter {
  constructor() {
    super();
  }
  connection() {
    throw new Error("Not implemented");
  }
  send() {
    throw new Error("Not implemented");
  }
  async detach() {
    throw new Error("Not implemented");
  }
  id() {
    throw new Error("Not implemented");
  }
};
var CDPSessionImpl = class extends CDPSession {
  constructor(connection, targetType, sessionId) {
    super();
    _CDPSessionImpl_sessionId.set(this, void 0);
    _CDPSessionImpl_targetType.set(this, void 0);
    _CDPSessionImpl_callbacks.set(this, new CallbackRegistry());
    _CDPSessionImpl_connection.set(this, void 0);
    __classPrivateFieldSet14(this, _CDPSessionImpl_connection, connection, "f");
    __classPrivateFieldSet14(this, _CDPSessionImpl_targetType, targetType, "f");
    __classPrivateFieldSet14(this, _CDPSessionImpl_sessionId, sessionId, "f");
  }
  connection() {
    return __classPrivateFieldGet18(this, _CDPSessionImpl_connection, "f");
  }
  send(method, ...paramArgs) {
    if (!__classPrivateFieldGet18(this, _CDPSessionImpl_connection, "f")) {
      return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${__classPrivateFieldGet18(this, _CDPSessionImpl_targetType, "f")} has been closed.`));
    }
    const params = paramArgs.length ? paramArgs[0] : void 0;
    return __classPrivateFieldGet18(this, _CDPSessionImpl_connection, "f")._rawSend(__classPrivateFieldGet18(this, _CDPSessionImpl_callbacks, "f"), method, params, __classPrivateFieldGet18(this, _CDPSessionImpl_sessionId, "f"));
  }
  _onMessage(object) {
    if (object.id) {
      if (object.error) {
        __classPrivateFieldGet18(this, _CDPSessionImpl_callbacks, "f").reject(object.id, createProtocolErrorMessage(object), object.error.message);
      } else {
        __classPrivateFieldGet18(this, _CDPSessionImpl_callbacks, "f").resolve(object.id, object.result);
      }
    } else {
      assert(!object.id);
      this.emit(object.method, object.params);
    }
  }
  async detach() {
    if (!__classPrivateFieldGet18(this, _CDPSessionImpl_connection, "f")) {
      throw new Error(`Session already detached. Most likely the ${__classPrivateFieldGet18(this, _CDPSessionImpl_targetType, "f")} has been closed.`);
    }
    await __classPrivateFieldGet18(this, _CDPSessionImpl_connection, "f").send("Target.detachFromTarget", {
      sessionId: __classPrivateFieldGet18(this, _CDPSessionImpl_sessionId, "f")
    });
  }
  _onClosed() {
    __classPrivateFieldGet18(this, _CDPSessionImpl_callbacks, "f").clear();
    __classPrivateFieldSet14(this, _CDPSessionImpl_connection, void 0, "f");
    this.emit(CDPSessionEmittedEvents.Disconnected);
  }
  id() {
    return __classPrivateFieldGet18(this, _CDPSessionImpl_sessionId, "f");
  }
};
_CDPSessionImpl_sessionId = /* @__PURE__ */ new WeakMap(), _CDPSessionImpl_targetType = /* @__PURE__ */ new WeakMap(), _CDPSessionImpl_callbacks = /* @__PURE__ */ new WeakMap(), _CDPSessionImpl_connection = /* @__PURE__ */ new WeakMap();
function createProtocolErrorMessage(object) {
  let message = `${object.error.message}`;
  if (object.error && typeof object.error === "object" && "data" in object.error) {
    message += ` ${object.error.data}`;
  }
  return message;
}
function rewriteError(error, message, originalMessage) {
  error.message = message;
  error.originalMessage = originalMessage != null ? originalMessage : error.originalMessage;
  return error;
}
function isTargetClosedError(error) {
  return error instanceof TargetCloseError;
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js
var __classPrivateFieldSet15 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet19 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ConsoleMessage_type;
var _ConsoleMessage_text;
var _ConsoleMessage_args;
var _ConsoleMessage_stackTraceLocations;
var ConsoleMessage = class {
  constructor(type, text, args, stackTraceLocations) {
    _ConsoleMessage_type.set(this, void 0);
    _ConsoleMessage_text.set(this, void 0);
    _ConsoleMessage_args.set(this, void 0);
    _ConsoleMessage_stackTraceLocations.set(this, void 0);
    __classPrivateFieldSet15(this, _ConsoleMessage_type, type, "f");
    __classPrivateFieldSet15(this, _ConsoleMessage_text, text, "f");
    __classPrivateFieldSet15(this, _ConsoleMessage_args, args, "f");
    __classPrivateFieldSet15(this, _ConsoleMessage_stackTraceLocations, stackTraceLocations, "f");
  }
  type() {
    return __classPrivateFieldGet19(this, _ConsoleMessage_type, "f");
  }
  text() {
    return __classPrivateFieldGet19(this, _ConsoleMessage_text, "f");
  }
  args() {
    return __classPrivateFieldGet19(this, _ConsoleMessage_args, "f");
  }
  location() {
    var _a2;
    return (_a2 = __classPrivateFieldGet19(this, _ConsoleMessage_stackTraceLocations, "f")[0]) != null ? _a2 : {};
  }
  stackTrace() {
    return __classPrivateFieldGet19(this, _ConsoleMessage_stackTraceLocations, "f");
  }
};
_ConsoleMessage_type = /* @__PURE__ */ new WeakMap(), _ConsoleMessage_text = /* @__PURE__ */ new WeakMap(), _ConsoleMessage_args = /* @__PURE__ */ new WeakMap(), _ConsoleMessage_stackTraceLocations = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Coverage.js
var __classPrivateFieldSet16 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet20 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Coverage_jsCoverage;
var _Coverage_cssCoverage;
var _JSCoverage_instances;
var _JSCoverage_client;
var _JSCoverage_enabled;
var _JSCoverage_scriptURLs;
var _JSCoverage_scriptSources;
var _JSCoverage_eventListeners;
var _JSCoverage_resetOnNavigation;
var _JSCoverage_reportAnonymousScripts;
var _JSCoverage_includeRawScriptCoverage;
var _JSCoverage_onExecutionContextsCleared;
var _JSCoverage_onScriptParsed;
var _CSSCoverage_instances;
var _CSSCoverage_client;
var _CSSCoverage_enabled;
var _CSSCoverage_stylesheetURLs;
var _CSSCoverage_stylesheetSources;
var _CSSCoverage_eventListeners;
var _CSSCoverage_resetOnNavigation;
var _CSSCoverage_onExecutionContextsCleared;
var _CSSCoverage_onStyleSheet;
var Coverage = class {
  constructor(client) {
    _Coverage_jsCoverage.set(this, void 0);
    _Coverage_cssCoverage.set(this, void 0);
    __classPrivateFieldSet16(this, _Coverage_jsCoverage, new JSCoverage(client), "f");
    __classPrivateFieldSet16(this, _Coverage_cssCoverage, new CSSCoverage(client), "f");
  }
  async startJSCoverage(options = {}) {
    return await __classPrivateFieldGet20(this, _Coverage_jsCoverage, "f").start(options);
  }
  async stopJSCoverage() {
    return await __classPrivateFieldGet20(this, _Coverage_jsCoverage, "f").stop();
  }
  async startCSSCoverage(options = {}) {
    return await __classPrivateFieldGet20(this, _Coverage_cssCoverage, "f").start(options);
  }
  async stopCSSCoverage() {
    return await __classPrivateFieldGet20(this, _Coverage_cssCoverage, "f").stop();
  }
};
_Coverage_jsCoverage = /* @__PURE__ */ new WeakMap(), _Coverage_cssCoverage = /* @__PURE__ */ new WeakMap();
var JSCoverage = class {
  constructor(client) {
    _JSCoverage_instances.add(this);
    _JSCoverage_client.set(this, void 0);
    _JSCoverage_enabled.set(this, false);
    _JSCoverage_scriptURLs.set(this, /* @__PURE__ */ new Map());
    _JSCoverage_scriptSources.set(this, /* @__PURE__ */ new Map());
    _JSCoverage_eventListeners.set(this, []);
    _JSCoverage_resetOnNavigation.set(this, false);
    _JSCoverage_reportAnonymousScripts.set(this, false);
    _JSCoverage_includeRawScriptCoverage.set(this, false);
    __classPrivateFieldSet16(this, _JSCoverage_client, client, "f");
  }
  async start(options = {}) {
    assert(!__classPrivateFieldGet20(this, _JSCoverage_enabled, "f"), "JSCoverage is already enabled");
    const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
    __classPrivateFieldSet16(this, _JSCoverage_resetOnNavigation, resetOnNavigation, "f");
    __classPrivateFieldSet16(this, _JSCoverage_reportAnonymousScripts, reportAnonymousScripts, "f");
    __classPrivateFieldSet16(this, _JSCoverage_includeRawScriptCoverage, includeRawScriptCoverage, "f");
    __classPrivateFieldSet16(this, _JSCoverage_enabled, true, "f");
    __classPrivateFieldGet20(this, _JSCoverage_scriptURLs, "f").clear();
    __classPrivateFieldGet20(this, _JSCoverage_scriptSources, "f").clear();
    __classPrivateFieldSet16(this, _JSCoverage_eventListeners, [
      addEventListener(__classPrivateFieldGet20(this, _JSCoverage_client, "f"), "Debugger.scriptParsed", __classPrivateFieldGet20(this, _JSCoverage_instances, "m", _JSCoverage_onScriptParsed).bind(this)),
      addEventListener(__classPrivateFieldGet20(this, _JSCoverage_client, "f"), "Runtime.executionContextsCleared", __classPrivateFieldGet20(this, _JSCoverage_instances, "m", _JSCoverage_onExecutionContextsCleared).bind(this))
    ], "f");
    await Promise.all([
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Profiler.enable"),
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Profiler.startPreciseCoverage", {
        callCount: __classPrivateFieldGet20(this, _JSCoverage_includeRawScriptCoverage, "f"),
        detailed: useBlockCoverage
      }),
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Debugger.enable"),
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Debugger.setSkipAllPauses", { skip: true })
    ]);
  }
  async stop() {
    assert(__classPrivateFieldGet20(this, _JSCoverage_enabled, "f"), "JSCoverage is not enabled");
    __classPrivateFieldSet16(this, _JSCoverage_enabled, false, "f");
    const result = await Promise.all([
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Profiler.takePreciseCoverage"),
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Profiler.stopPreciseCoverage"),
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Profiler.disable"),
      __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Debugger.disable")
    ]);
    removeEventListeners(__classPrivateFieldGet20(this, _JSCoverage_eventListeners, "f"));
    const coverage = [];
    const profileResponse = result[0];
    for (const entry of profileResponse.result) {
      let url = __classPrivateFieldGet20(this, _JSCoverage_scriptURLs, "f").get(entry.scriptId);
      if (!url && __classPrivateFieldGet20(this, _JSCoverage_reportAnonymousScripts, "f")) {
        url = "debugger://VM" + entry.scriptId;
      }
      const text = __classPrivateFieldGet20(this, _JSCoverage_scriptSources, "f").get(entry.scriptId);
      if (text === void 0 || url === void 0) {
        continue;
      }
      const flattenRanges = [];
      for (const func of entry.functions) {
        flattenRanges.push(...func.ranges);
      }
      const ranges = convertToDisjointRanges(flattenRanges);
      if (!__classPrivateFieldGet20(this, _JSCoverage_includeRawScriptCoverage, "f")) {
        coverage.push({ url, ranges, text });
      } else {
        coverage.push({ url, ranges, text, rawScriptCoverage: entry });
      }
    }
    return coverage;
  }
};
_JSCoverage_client = /* @__PURE__ */ new WeakMap(), _JSCoverage_enabled = /* @__PURE__ */ new WeakMap(), _JSCoverage_scriptURLs = /* @__PURE__ */ new WeakMap(), _JSCoverage_scriptSources = /* @__PURE__ */ new WeakMap(), _JSCoverage_eventListeners = /* @__PURE__ */ new WeakMap(), _JSCoverage_resetOnNavigation = /* @__PURE__ */ new WeakMap(), _JSCoverage_reportAnonymousScripts = /* @__PURE__ */ new WeakMap(), _JSCoverage_includeRawScriptCoverage = /* @__PURE__ */ new WeakMap(), _JSCoverage_instances = /* @__PURE__ */ new WeakSet(), _JSCoverage_onExecutionContextsCleared = function _JSCoverage_onExecutionContextsCleared2() {
  if (!__classPrivateFieldGet20(this, _JSCoverage_resetOnNavigation, "f")) {
    return;
  }
  __classPrivateFieldGet20(this, _JSCoverage_scriptURLs, "f").clear();
  __classPrivateFieldGet20(this, _JSCoverage_scriptSources, "f").clear();
}, _JSCoverage_onScriptParsed = async function _JSCoverage_onScriptParsed2(event) {
  if (PuppeteerURL.isPuppeteerURL(event.url)) {
    return;
  }
  if (!event.url && !__classPrivateFieldGet20(this, _JSCoverage_reportAnonymousScripts, "f")) {
    return;
  }
  try {
    const response = await __classPrivateFieldGet20(this, _JSCoverage_client, "f").send("Debugger.getScriptSource", {
      scriptId: event.scriptId
    });
    __classPrivateFieldGet20(this, _JSCoverage_scriptURLs, "f").set(event.scriptId, event.url);
    __classPrivateFieldGet20(this, _JSCoverage_scriptSources, "f").set(event.scriptId, response.scriptSource);
  } catch (error) {
    debugError(error);
  }
};
var CSSCoverage = class {
  constructor(client) {
    _CSSCoverage_instances.add(this);
    _CSSCoverage_client.set(this, void 0);
    _CSSCoverage_enabled.set(this, false);
    _CSSCoverage_stylesheetURLs.set(this, /* @__PURE__ */ new Map());
    _CSSCoverage_stylesheetSources.set(this, /* @__PURE__ */ new Map());
    _CSSCoverage_eventListeners.set(this, []);
    _CSSCoverage_resetOnNavigation.set(this, false);
    __classPrivateFieldSet16(this, _CSSCoverage_client, client, "f");
  }
  async start(options = {}) {
    assert(!__classPrivateFieldGet20(this, _CSSCoverage_enabled, "f"), "CSSCoverage is already enabled");
    const { resetOnNavigation = true } = options;
    __classPrivateFieldSet16(this, _CSSCoverage_resetOnNavigation, resetOnNavigation, "f");
    __classPrivateFieldSet16(this, _CSSCoverage_enabled, true, "f");
    __classPrivateFieldGet20(this, _CSSCoverage_stylesheetURLs, "f").clear();
    __classPrivateFieldGet20(this, _CSSCoverage_stylesheetSources, "f").clear();
    __classPrivateFieldSet16(this, _CSSCoverage_eventListeners, [
      addEventListener(__classPrivateFieldGet20(this, _CSSCoverage_client, "f"), "CSS.styleSheetAdded", __classPrivateFieldGet20(this, _CSSCoverage_instances, "m", _CSSCoverage_onStyleSheet).bind(this)),
      addEventListener(__classPrivateFieldGet20(this, _CSSCoverage_client, "f"), "Runtime.executionContextsCleared", __classPrivateFieldGet20(this, _CSSCoverage_instances, "m", _CSSCoverage_onExecutionContextsCleared).bind(this))
    ], "f");
    await Promise.all([
      __classPrivateFieldGet20(this, _CSSCoverage_client, "f").send("DOM.enable"),
      __classPrivateFieldGet20(this, _CSSCoverage_client, "f").send("CSS.enable"),
      __classPrivateFieldGet20(this, _CSSCoverage_client, "f").send("CSS.startRuleUsageTracking")
    ]);
  }
  async stop() {
    assert(__classPrivateFieldGet20(this, _CSSCoverage_enabled, "f"), "CSSCoverage is not enabled");
    __classPrivateFieldSet16(this, _CSSCoverage_enabled, false, "f");
    const ruleTrackingResponse = await __classPrivateFieldGet20(this, _CSSCoverage_client, "f").send("CSS.stopRuleUsageTracking");
    await Promise.all([
      __classPrivateFieldGet20(this, _CSSCoverage_client, "f").send("CSS.disable"),
      __classPrivateFieldGet20(this, _CSSCoverage_client, "f").send("DOM.disable")
    ]);
    removeEventListeners(__classPrivateFieldGet20(this, _CSSCoverage_eventListeners, "f"));
    const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
    for (const entry of ruleTrackingResponse.ruleUsage) {
      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
      if (!ranges) {
        ranges = [];
        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
      }
      ranges.push({
        startOffset: entry.startOffset,
        endOffset: entry.endOffset,
        count: entry.used ? 1 : 0
      });
    }
    const coverage = [];
    for (const styleSheetId of __classPrivateFieldGet20(this, _CSSCoverage_stylesheetURLs, "f").keys()) {
      const url = __classPrivateFieldGet20(this, _CSSCoverage_stylesheetURLs, "f").get(styleSheetId);
      assert(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
      const text = __classPrivateFieldGet20(this, _CSSCoverage_stylesheetSources, "f").get(styleSheetId);
      assert(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
      coverage.push({ url, ranges, text });
    }
    return coverage;
  }
};
_CSSCoverage_client = /* @__PURE__ */ new WeakMap(), _CSSCoverage_enabled = /* @__PURE__ */ new WeakMap(), _CSSCoverage_stylesheetURLs = /* @__PURE__ */ new WeakMap(), _CSSCoverage_stylesheetSources = /* @__PURE__ */ new WeakMap(), _CSSCoverage_eventListeners = /* @__PURE__ */ new WeakMap(), _CSSCoverage_resetOnNavigation = /* @__PURE__ */ new WeakMap(), _CSSCoverage_instances = /* @__PURE__ */ new WeakSet(), _CSSCoverage_onExecutionContextsCleared = function _CSSCoverage_onExecutionContextsCleared2() {
  if (!__classPrivateFieldGet20(this, _CSSCoverage_resetOnNavigation, "f")) {
    return;
  }
  __classPrivateFieldGet20(this, _CSSCoverage_stylesheetURLs, "f").clear();
  __classPrivateFieldGet20(this, _CSSCoverage_stylesheetSources, "f").clear();
}, _CSSCoverage_onStyleSheet = async function _CSSCoverage_onStyleSheet2(event) {
  const header = event.header;
  if (!header.sourceURL) {
    return;
  }
  try {
    const response = await __classPrivateFieldGet20(this, _CSSCoverage_client, "f").send("CSS.getStyleSheetText", {
      styleSheetId: header.styleSheetId
    });
    __classPrivateFieldGet20(this, _CSSCoverage_stylesheetURLs, "f").set(header.styleSheetId, header.sourceURL);
    __classPrivateFieldGet20(this, _CSSCoverage_stylesheetSources, "f").set(header.styleSheetId, response.text);
  } catch (error) {
    debugError(error);
  }
};
function convertToDisjointRanges(nestedRanges) {
  const points = [];
  for (const range of nestedRanges) {
    points.push({ offset: range.startOffset, type: 0, range });
    points.push({ offset: range.endOffset, type: 1, range });
  }
  points.sort((a, b) => {
    if (a.offset !== b.offset) {
      return a.offset - b.offset;
    }
    if (a.type !== b.type) {
      return b.type - a.type;
    }
    const aLength = a.range.endOffset - a.range.startOffset;
    const bLength = b.range.endOffset - b.range.startOffset;
    if (a.type === 0) {
      return bLength - aLength;
    }
    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0;
  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results[results.length - 1];
      if (lastResult && lastResult.end === lastOffset) {
        lastResult.end = point.offset;
      } else {
        results.push({ start: lastOffset, end: point.offset });
      }
    }
    lastOffset = point.offset;
    if (point.type === 0) {
      hitCountStack.push(point.range.count);
    } else {
      hitCountStack.pop();
    }
  }
  return results.filter((range) => {
    return range.end - range.start > 0;
  });
}

// node_modules/puppeteer-core/lib/esm/puppeteer/common/EmulationManager.js
var __classPrivateFieldSet17 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet21 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EmulationManager_client;
var _EmulationManager_emulatingMobile;
var _EmulationManager_hasTouch;
var _EmulationManager_javascriptEnabled;
var EmulationManager = class {
  constructor(client) {
    _EmulationManager_client.set(this, void 0);
    _EmulationManager_emulatingMobile.set(this, false);
    _EmulationManager_hasTouch.set(this, false);
    _EmulationManager_javascriptEnabled.set(this, true);
    __classPrivateFieldSet17(this, _EmulationManager_client, client, "f");
  }
  get javascriptEnabled() {
    return __classPrivateFieldGet21(this, _EmulationManager_javascriptEnabled, "f");
  }
  async emulateViewport(viewport) {
    var _a2;
    const mobile = viewport.isMobile || false;
    const width = viewport.width;
    const height = viewport.height;
    const deviceScaleFactor = (_a2 = viewport.deviceScaleFactor) != null ? _a2 : 1;
    const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
    const hasTouch = viewport.hasTouch || false;
    await Promise.all([
      __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setDeviceMetricsOverride", {
        mobile,
        width,
        height,
        deviceScaleFactor,
        screenOrientation
      }),
      __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setTouchEmulationEnabled", {
        enabled: hasTouch
      })
    ]);
    const reloadNeeded = __classPrivateFieldGet21(this, _EmulationManager_emulatingMobile, "f") !== mobile || __classPrivateFieldGet21(this, _EmulationManager_hasTouch, "f") !== hasTouch;
    __classPrivateFieldSet17(this, _EmulationManager_emulatingMobile, mobile, "f");
    __classPrivateFieldSet17(this, _EmulationManager_hasTouch, hasTouch, "f");
    return reloadNeeded;
  }
  async emulateIdleState(overrides) {
    if (overrides) {
      await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setIdleOverride", {
        isUserActive: overrides.isUserActive,
        isScreenUnlocked: overrides.isScreenUnlocked
      });
    } else {
      await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.clearIdleOverride");
    }
  }
  async emulateTimezone(timezoneId) {
    try {
      await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setTimezoneOverride", {
        timezoneId: timezoneId || ""
      });
    } catch (error) {
      if (isErrorLike(error) && error.message.includes("Invalid timezone")) {
        throw new Error(`Invalid timezone ID: ${timezoneId}`);
      }
      throw error;
    }
  }
  async emulateVisionDeficiency(type) {
    const visionDeficiencies = /* @__PURE__ */ new Set([
      "none",
      "achromatopsia",
      "blurredVision",
      "deuteranopia",
      "protanopia",
      "tritanopia"
    ]);
    try {
      assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
      await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setEmulatedVisionDeficiency", {
        type: type || "none"
      });
    } catch (error) {
      throw error;
    }
  }
  async emulateCPUThrottling(factor) {
    assert(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
    await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setCPUThrottlingRate", {
      rate: factor != null ? factor : 1
    });
  }
  async emulateMediaFeatures(features) {
    if (!features) {
      await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setEmulatedMedia", {});
    }
    if (Array.isArray(features)) {
      for (const mediaFeature of features) {
        const name = mediaFeature.name;
        assert(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), "Unsupported media feature: " + name);
      }
      await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setEmulatedMedia", {
        features
      });
    }
  }
  async emulateMediaType(type) {
    assert(type === "screen" || type === "print" || (type != null ? type : void 0) === void 0, "Unsupported media type: " + type);
    await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setEmulatedMedia", {
      media: type || ""
    });
  }
  async setGeolocation(options) {
    const { longitude, latitude, accuracy = 0 } = options;
    if (longitude < -180 || longitude > 180) {
      throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
    }
    if (latitude < -90 || latitude > 90) {
      throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
    }
    if (accuracy < 0) {
      throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
    }
    await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setGeolocationOverride", {
      longitude,
      latitude,
      accuracy
    });
  }
  async resetDefaultBackgroundColor() {
    await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setDefaultBackgroundColorOverride");
  }
  async setTransparentBackgroundColor() {
    await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setDefaultBackgroundColorOverride", {
      color: { r: 0, g: 0, b: 0, a: 0 }
    });
  }
  async setJavaScriptEnabled(enabled) {
    if (__classPrivateFieldGet21(this, _EmulationManager_javascriptEnabled, "f") === enabled) {
      return;
    }
    __classPrivateFieldSet17(this, _EmulationManager_javascriptEnabled, enabled, "f");
    await __classPrivateFieldGet21(this, _EmulationManager_client, "f").send("Emulation.setScriptExecutionDisabled", {
      value: !enabled
    });
  }
};
_EmulationManager_client = /* @__PURE__ */ new WeakMap(), _EmulationManager_emulatingMobile = /* @__PURE__ */ new WeakMap(), _EmulationManager_hasTouch = /* @__PURE__ */ new WeakMap(), _EmulationManager_javascriptEnabled = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/DeviceRequestPrompt.js
var __classPrivateFieldSet18 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet22 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DeviceRequestPrompt_instances;
var _DeviceRequestPrompt_client;
var _DeviceRequestPrompt_timeoutSettings;
var _DeviceRequestPrompt_id;
var _DeviceRequestPrompt_handled;
var _DeviceRequestPrompt_updateDevicesHandle;
var _DeviceRequestPrompt_waitForDevicePromises;
var _DeviceRequestPrompt_updateDevices;
var _DeviceRequestPromptManager_instances;
var _DeviceRequestPromptManager_client;
var _DeviceRequestPromptManager_timeoutSettings;
var _DeviceRequestPromptManager_deviceRequestPrompDeferreds;
var _DeviceRequestPromptManager_onDeviceRequestPrompted;
var DeviceRequestPromptDevice = class {
  constructor(id, name) {
    this.id = id;
    this.name = name;
  }
};
var DeviceRequestPrompt = class {
  constructor(client, timeoutSettings, firstEvent) {
    _DeviceRequestPrompt_instances.add(this);
    _DeviceRequestPrompt_client.set(this, void 0);
    _DeviceRequestPrompt_timeoutSettings.set(this, void 0);
    _DeviceRequestPrompt_id.set(this, void 0);
    _DeviceRequestPrompt_handled.set(this, false);
    _DeviceRequestPrompt_updateDevicesHandle.set(this, __classPrivateFieldGet22(this, _DeviceRequestPrompt_instances, "m", _DeviceRequestPrompt_updateDevices).bind(this));
    _DeviceRequestPrompt_waitForDevicePromises.set(this, /* @__PURE__ */ new Set());
    this.devices = [];
    __classPrivateFieldSet18(this, _DeviceRequestPrompt_client, client, "f");
    __classPrivateFieldSet18(this, _DeviceRequestPrompt_timeoutSettings, timeoutSettings, "f");
    __classPrivateFieldSet18(this, _DeviceRequestPrompt_id, firstEvent.id, "f");
    __classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f").on("DeviceAccess.deviceRequestPrompted", __classPrivateFieldGet22(this, _DeviceRequestPrompt_updateDevicesHandle, "f"));
    __classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f").on("Target.detachedFromTarget", () => {
      __classPrivateFieldSet18(this, _DeviceRequestPrompt_client, null, "f");
    });
    __classPrivateFieldGet22(this, _DeviceRequestPrompt_instances, "m", _DeviceRequestPrompt_updateDevices).call(this, firstEvent);
  }
  async waitForDevice(filter, options = {}) {
    for (const device of this.devices) {
      if (filter(device)) {
        return device;
      }
    }
    const { timeout = __classPrivateFieldGet22(this, _DeviceRequestPrompt_timeoutSettings, "f").timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout}ms exceeded`,
      timeout
    });
    const handle = { filter, promise: deferred };
    __classPrivateFieldGet22(this, _DeviceRequestPrompt_waitForDevicePromises, "f").add(handle);
    try {
      return await deferred.valueOrThrow();
    } finally {
      __classPrivateFieldGet22(this, _DeviceRequestPrompt_waitForDevicePromises, "f").delete(handle);
    }
  }
  async select(device) {
    assert(__classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f") !== null, "Cannot select device through detached session!");
    assert(this.devices.includes(device), "Cannot select unknown device!");
    assert(!__classPrivateFieldGet22(this, _DeviceRequestPrompt_handled, "f"), "Cannot select DeviceRequestPrompt which is already handled!");
    __classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f").off("DeviceAccess.deviceRequestPrompted", __classPrivateFieldGet22(this, _DeviceRequestPrompt_updateDevicesHandle, "f"));
    __classPrivateFieldSet18(this, _DeviceRequestPrompt_handled, true, "f");
    return __classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f").send("DeviceAccess.selectPrompt", {
      id: __classPrivateFieldGet22(this, _DeviceRequestPrompt_id, "f"),
      deviceId: device.id
    });
  }
  async cancel() {
    assert(__classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f") !== null, "Cannot cancel prompt through detached session!");
    assert(!__classPrivateFieldGet22(this, _DeviceRequestPrompt_handled, "f"), "Cannot cancel DeviceRequestPrompt which is already handled!");
    __classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f").off("DeviceAccess.deviceRequestPrompted", __classPrivateFieldGet22(this, _DeviceRequestPrompt_updateDevicesHandle, "f"));
    __classPrivateFieldSet18(this, _DeviceRequestPrompt_handled, true, "f");
    return __classPrivateFieldGet22(this, _DeviceRequestPrompt_client, "f").send("DeviceAccess.cancelPrompt", { id: __classPrivateFieldGet22(this, _DeviceRequestPrompt_id, "f") });
  }
};
_DeviceRequestPrompt_client = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_timeoutSettings = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_id = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_handled = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_updateDevicesHandle = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_waitForDevicePromises = /* @__PURE__ */ new WeakMap(), _DeviceRequestPrompt_instances = /* @__PURE__ */ new WeakSet(), _DeviceRequestPrompt_updateDevices = function _DeviceRequestPrompt_updateDevices2(event) {
  if (event.id !== __classPrivateFieldGet22(this, _DeviceRequestPrompt_id, "f")) {
    return;
  }
  for (const rawDevice of event.devices) {
    if (this.devices.some((device) => {
      return device.id === rawDevice.id;
    })) {
      continue;
    }
    const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
    this.devices.push(newDevice);
    for (const waitForDevicePromise of __classPrivateFieldGet22(this, _DeviceRequestPrompt_waitForDevicePromises, "f")) {
      if (waitForDevicePromise.filter(newDevice)) {
        waitForDevicePromise.promise.resolve(newDevice);
      }
    }
  }
};
var DeviceRequestPromptManager = class {
  constructor(client, timeoutSettings) {
    _DeviceRequestPromptManager_instances.add(this);
    _DeviceRequestPromptManager_client.set(this, void 0);
    _DeviceRequestPromptManager_timeoutSettings.set(this, void 0);
    _DeviceRequestPromptManager_deviceRequestPrompDeferreds.set(this, /* @__PURE__ */ new Set());
    __classPrivateFieldSet18(this, _DeviceRequestPromptManager_client, client, "f");
    __classPrivateFieldSet18(this, _DeviceRequestPromptManager_timeoutSettings, timeoutSettings, "f");
    __classPrivateFieldGet22(this, _DeviceRequestPromptManager_client, "f").on("DeviceAccess.deviceRequestPrompted", (event) => {
      __classPrivateFieldGet22(this, _DeviceRequestPromptManager_instances, "m", _DeviceRequestPromptManager_onDeviceRequestPrompted).call(this, event);
    });
    __classPrivateFieldGet22(this, _DeviceRequestPromptManager_client, "f").on("Target.detachedFromTarget", () => {
      __classPrivateFieldSet18(this, _DeviceRequestPromptManager_client, null, "f");
    });
  }
  async waitForDevicePrompt(options = {}) {
    assert(__classPrivateFieldGet22(this, _DeviceRequestPromptManager_client, "f") !== null, "Cannot wait for device prompt through detached session!");
    const needsEnable = __classPrivateFieldGet22(this, _DeviceRequestPromptManager_deviceRequestPrompDeferreds, "f").size === 0;
    let enablePromise;
    if (needsEnable) {
      enablePromise = __classPrivateFieldGet22(this, _DeviceRequestPromptManager_client, "f").send("DeviceAccess.enable");
    }
    const { timeout = __classPrivateFieldGet22(this, _DeviceRequestPromptManager_timeoutSettings, "f").timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout}ms exceeded`,
      timeout
    });
    __classPrivateFieldGet22(this, _DeviceRequestPromptManager_deviceRequestPrompDeferreds, "f").add(deferred);
    try {
      const [result] = await Promise.all([
        deferred.valueOrThrow(),
        enablePromise
      ]);
      return result;
    } finally {
      __classPrivateFieldGet22(this, _DeviceRequestPromptManager_deviceRequestPrompDeferreds, "f").delete(deferred);
    }
  }
};
_DeviceRequestPromptManager_client = /* @__PURE__ */ new WeakMap(), _DeviceRequestPromptManager_timeoutSettings = /* @__PURE__ */ new WeakMap(), _DeviceRequestPromptManager_deviceRequestPrompDeferreds = /* @__PURE__ */ new WeakMap(), _DeviceRequestPromptManager_instances = /* @__PURE__ */ new WeakSet(), _DeviceRequestPromptManager_onDeviceRequestPrompted = function _DeviceRequestPromptManager_onDeviceRequestPrompted2(event) {
  if (!__classPrivateFieldGet22(this, _DeviceRequestPromptManager_deviceRequestPrompDeferreds, "f").size) {
    return;
  }
  assert(__classPrivateFieldGet22(this, _DeviceRequestPromptManager_client, "f") !== null);
  const devicePrompt = new DeviceRequestPrompt(__classPrivateFieldGet22(this, _DeviceRequestPromptManager_client, "f"), __classPrivateFieldGet22(this, _DeviceRequestPromptManager_timeoutSettings, "f"), event);
  for (const promise of __classPrivateFieldGet22(this, _DeviceRequestPromptManager_deviceRequestPrompDeferreds, "f")) {
    promise.resolve(devicePrompt);
  }
  __classPrivateFieldGet22(this, _DeviceRequestPromptManager_deviceRequestPrompDeferreds, "f").clear();
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Binding.js
var __classPrivateFieldSet19 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet23 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Binding_name;
var _Binding_fn;
var Binding = class {
  constructor(name, fn) {
    _Binding_name.set(this, void 0);
    _Binding_fn.set(this, void 0);
    __classPrivateFieldSet19(this, _Binding_name, name, "f");
    __classPrivateFieldSet19(this, _Binding_fn, fn, "f");
  }
  get name() {
    return __classPrivateFieldGet23(this, _Binding_name, "f");
  }
  async run(context, id, args, isTrivial) {
    const garbage = [];
    try {
      if (!isTrivial) {
        const handles = await context.evaluateHandle((name, seq) => {
          return globalThis[name].args.get(seq);
        }, __classPrivateFieldGet23(this, _Binding_name, "f"), id);
        try {
          const properties = await handles.getProperties();
          for (const [index, handle] of properties) {
            if (index in args) {
              switch (handle.remoteObject().subtype) {
                case "node":
                  args[+index] = handle;
                  break;
                default:
                  garbage.push(handle.dispose());
              }
            } else {
              garbage.push(handle.dispose());
            }
          }
        } finally {
          await handles.dispose();
        }
      }
      await context.evaluate((name, seq, result) => {
        const callbacks = globalThis[name].callbacks;
        callbacks.get(seq).resolve(result);
        callbacks.delete(seq);
      }, __classPrivateFieldGet23(this, _Binding_name, "f"), id, await __classPrivateFieldGet23(this, _Binding_fn, "f").call(this, ...args));
      for (const arg of args) {
        if (arg instanceof JSHandle) {
          garbage.push(arg.dispose());
        }
      }
    } catch (error) {
      if (isErrorLike(error)) {
        await context.evaluate((name, seq, message, stack) => {
          const error2 = new Error(message);
          error2.stack = stack;
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq).reject(error2);
          callbacks.delete(seq);
        }, __classPrivateFieldGet23(this, _Binding_name, "f"), id, error.message, error.stack).catch(debugError);
      } else {
        await context.evaluate((name, seq, error2) => {
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq).reject(error2);
          callbacks.delete(seq);
        }, __classPrivateFieldGet23(this, _Binding_name, "f"), id, error).catch(debugError);
      }
    } finally {
      await Promise.all(garbage);
    }
  }
};
_Binding_name = /* @__PURE__ */ new WeakMap(), _Binding_fn = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/ExecutionContext.js
var __classPrivateFieldGet24 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet20 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _ExecutionContext_instances;
var _ExecutionContext_bindingsInstalled;
var _ExecutionContext_puppeteerUtil;
var _ExecutionContext_installGlobalBinding;
var _ExecutionContext_evaluate;
var SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
var getSourceUrlComment = (url) => {
  return `//# sourceURL=${url}`;
};
var ExecutionContext = class {
  constructor(client, contextPayload, world) {
    _ExecutionContext_instances.add(this);
    _ExecutionContext_bindingsInstalled.set(this, false);
    _ExecutionContext_puppeteerUtil.set(this, void 0);
    this._client = client;
    this._world = world;
    this._contextId = contextPayload.id;
    if (contextPayload.name) {
      this._contextName = contextPayload.name;
    }
  }
  get puppeteerUtil() {
    let promise = Promise.resolve();
    if (!__classPrivateFieldGet24(this, _ExecutionContext_bindingsInstalled, "f")) {
      promise = Promise.all([
        __classPrivateFieldGet24(this, _ExecutionContext_instances, "m", _ExecutionContext_installGlobalBinding).call(this, new Binding("__ariaQuerySelector", ARIAQueryHandler.queryOne)),
        __classPrivateFieldGet24(this, _ExecutionContext_instances, "m", _ExecutionContext_installGlobalBinding).call(this, new Binding("__ariaQuerySelectorAll", async (element, selector) => {
          const results = ARIAQueryHandler.queryAll(element, selector);
          return element.executionContext().evaluateHandle((...elements) => {
            return elements;
          }, ...await AsyncIterableUtil.collect(results));
        }))
      ]);
      __classPrivateFieldSet20(this, _ExecutionContext_bindingsInstalled, true, "f");
    }
    scriptInjector.inject((script) => {
      if (__classPrivateFieldGet24(this, _ExecutionContext_puppeteerUtil, "f")) {
        void __classPrivateFieldGet24(this, _ExecutionContext_puppeteerUtil, "f").then((handle) => {
          void handle.dispose();
        });
      }
      __classPrivateFieldSet20(this, _ExecutionContext_puppeteerUtil, promise.then(() => {
        return this.evaluateHandle(script);
      }), "f");
    }, !__classPrivateFieldGet24(this, _ExecutionContext_puppeteerUtil, "f"));
    return __classPrivateFieldGet24(this, _ExecutionContext_puppeteerUtil, "f");
  }
  async evaluate(pageFunction, ...args) {
    return await __classPrivateFieldGet24(this, _ExecutionContext_instances, "m", _ExecutionContext_evaluate).call(this, true, pageFunction, ...args);
  }
  async evaluateHandle(pageFunction, ...args) {
    return __classPrivateFieldGet24(this, _ExecutionContext_instances, "m", _ExecutionContext_evaluate).call(this, false, pageFunction, ...args);
  }
};
_ExecutionContext_bindingsInstalled = /* @__PURE__ */ new WeakMap(), _ExecutionContext_puppeteerUtil = /* @__PURE__ */ new WeakMap(), _ExecutionContext_instances = /* @__PURE__ */ new WeakSet(), _ExecutionContext_installGlobalBinding = async function _ExecutionContext_installGlobalBinding2(binding) {
  try {
    if (this._world) {
      this._world._bindings.set(binding.name, binding);
      await this._world._addBindingToContext(this, binding.name);
    }
  } catch {
  }
}, _ExecutionContext_evaluate = async function _ExecutionContext_evaluate2(returnByValue, pageFunction, ...args) {
  var _a2, _b;
  const sourceUrlComment = getSourceUrlComment((_b = (_a2 = getSourcePuppeteerURLIfAvailable(pageFunction)) == null ? void 0 : _a2.toString()) != null ? _b : PuppeteerURL.INTERNAL_URL);
  if (isString(pageFunction)) {
    const contextId = this._contextId;
    const expression = pageFunction;
    const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}
${sourceUrlComment}
`;
    const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this._client.send("Runtime.evaluate", {
      expression: expressionWithSourceUrl,
      contextId,
      returnByValue,
      awaitPromise: true,
      userGesture: true
    }).catch(rewriteError2);
    if (exceptionDetails2) {
      throw createEvaluationError(exceptionDetails2);
    }
    return returnByValue ? valueFromRemoteObject(remoteObject2) : createJSHandle(this, remoteObject2);
  }
  const functionDeclaration = stringifyFunction(pageFunction);
  const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
  let callFunctionOnPromise;
  try {
    callFunctionOnPromise = this._client.send("Runtime.callFunctionOn", {
      functionDeclaration: functionDeclarationWithSourceUrl,
      executionContextId: this._contextId,
      arguments: await Promise.all(args.map(convertArgument.bind(this))),
      returnByValue,
      awaitPromise: true,
      userGesture: true
    });
  } catch (error) {
    if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
      error.message += " Recursive objects are not allowed.";
    }
    throw error;
  }
  const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError2);
  if (exceptionDetails) {
    throw createEvaluationError(exceptionDetails);
  }
  return returnByValue ? valueFromRemoteObject(remoteObject) : createJSHandle(this, remoteObject);
  async function convertArgument(arg) {
    if (arg instanceof LazyArg) {
      arg = await arg.get(this);
    }
    if (typeof arg === "bigint") {
      return { unserializableValue: `${arg.toString()}n` };
    }
    if (Object.is(arg, -0)) {
      return { unserializableValue: "-0" };
    }
    if (Object.is(arg, Infinity)) {
      return { unserializableValue: "Infinity" };
    }
    if (Object.is(arg, -Infinity)) {
      return { unserializableValue: "-Infinity" };
    }
    if (Object.is(arg, NaN)) {
      return { unserializableValue: "NaN" };
    }
    const objectHandle = arg && (arg instanceof CDPJSHandle || arg instanceof CDPElementHandle) ? arg : null;
    if (objectHandle) {
      if (objectHandle.executionContext() !== this) {
        throw new Error("JSHandles can be evaluated only in the context they were created!");
      }
      if (objectHandle.disposed) {
        throw new Error("JSHandle is disposed!");
      }
      if (objectHandle.remoteObject().unserializableValue) {
        return {
          unserializableValue: objectHandle.remoteObject().unserializableValue
        };
      }
      if (!objectHandle.remoteObject().objectId) {
        return { value: objectHandle.remoteObject().value };
      }
      return { objectId: objectHandle.remoteObject().objectId };
    }
    return { value: arg };
  }
};
var rewriteError2 = (error) => {
  if (error.message.includes("Object reference chain is too long")) {
    return { result: { type: "undefined" } };
  }
  if (error.message.includes("Object couldn't be returned by value")) {
    return { result: { type: "undefined" } };
  }
  if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  }
  throw error;
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/IsolatedWorlds.js
var MAIN_WORLD = Symbol("mainWorld");
var PUPPETEER_WORLD = Symbol("puppeteerWorld");

// node_modules/puppeteer-core/lib/esm/puppeteer/common/WaitTask.js
var __classPrivateFieldSet21 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet25 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WaitTask_world;
var _WaitTask_polling;
var _WaitTask_root;
var _WaitTask_fn;
var _WaitTask_args;
var _WaitTask_timeout;
var _WaitTask_result;
var _WaitTask_poller;
var _WaitTask_signal;
var _TaskManager_tasks;
var WaitTask = class {
  constructor(world, options, fn, ...args) {
    var _a2;
    _WaitTask_world.set(this, void 0);
    _WaitTask_polling.set(this, void 0);
    _WaitTask_root.set(this, void 0);
    _WaitTask_fn.set(this, void 0);
    _WaitTask_args.set(this, void 0);
    _WaitTask_timeout.set(this, void 0);
    _WaitTask_result.set(this, Deferred.create());
    _WaitTask_poller.set(this, void 0);
    _WaitTask_signal.set(this, void 0);
    __classPrivateFieldSet21(this, _WaitTask_world, world, "f");
    __classPrivateFieldSet21(this, _WaitTask_polling, options.polling, "f");
    __classPrivateFieldSet21(this, _WaitTask_root, options.root, "f");
    __classPrivateFieldSet21(this, _WaitTask_signal, options.signal, "f");
    (_a2 = __classPrivateFieldGet25(this, _WaitTask_signal, "f")) == null ? void 0 : _a2.addEventListener("abort", () => {
      var _a3;
      void this.terminate((_a3 = __classPrivateFieldGet25(this, _WaitTask_signal, "f")) == null ? void 0 : _a3.reason);
    }, {
      once: true
    });
    switch (typeof fn) {
      case "string":
        __classPrivateFieldSet21(this, _WaitTask_fn, `() => {return (${fn});}`, "f");
        break;
      default:
        __classPrivateFieldSet21(this, _WaitTask_fn, stringifyFunction(fn), "f");
        break;
    }
    __classPrivateFieldSet21(this, _WaitTask_args, args, "f");
    __classPrivateFieldGet25(this, _WaitTask_world, "f").taskManager.add(this);
    if (options.timeout) {
      __classPrivateFieldSet21(this, _WaitTask_timeout, setTimeout(() => {
        void this.terminate(new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));
      }, options.timeout), "f");
    }
    void this.rerun();
  }
  get result() {
    return __classPrivateFieldGet25(this, _WaitTask_result, "f").valueOrThrow();
  }
  async rerun() {
    try {
      switch (__classPrivateFieldGet25(this, _WaitTask_polling, "f")) {
        case "raf":
          __classPrivateFieldSet21(this, _WaitTask_poller, await __classPrivateFieldGet25(this, _WaitTask_world, "f").evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn, ...args) => {
            const fun = createFunction2(fn);
            return new RAFPoller(() => {
              return fun(...args);
            });
          }, LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), __classPrivateFieldGet25(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet25(this, _WaitTask_args, "f")), "f");
          break;
        case "mutation":
          __classPrivateFieldSet21(this, _WaitTask_poller, await __classPrivateFieldGet25(this, _WaitTask_world, "f").evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root, fn, ...args) => {
            const fun = createFunction2(fn);
            return new MutationPoller(() => {
              return fun(...args);
            }, root || document);
          }, LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), __classPrivateFieldGet25(this, _WaitTask_root, "f"), __classPrivateFieldGet25(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet25(this, _WaitTask_args, "f")), "f");
          break;
        default:
          __classPrivateFieldSet21(this, _WaitTask_poller, await __classPrivateFieldGet25(this, _WaitTask_world, "f").evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms, fn, ...args) => {
            const fun = createFunction2(fn);
            return new IntervalPoller(() => {
              return fun(...args);
            }, ms);
          }, LazyArg.create((context) => {
            return context.puppeteerUtil;
          }), __classPrivateFieldGet25(this, _WaitTask_polling, "f"), __classPrivateFieldGet25(this, _WaitTask_fn, "f"), ...__classPrivateFieldGet25(this, _WaitTask_args, "f")), "f");
          break;
      }
      await __classPrivateFieldGet25(this, _WaitTask_poller, "f").evaluate((poller) => {
        void poller.start();
      });
      const result = await __classPrivateFieldGet25(this, _WaitTask_poller, "f").evaluateHandle((poller) => {
        return poller.result();
      });
      __classPrivateFieldGet25(this, _WaitTask_result, "f").resolve(result);
      await this.terminate();
    } catch (error) {
      const badError = this.getBadError(error);
      if (badError) {
        await this.terminate(badError);
      }
    }
  }
  async terminate(error) {
    __classPrivateFieldGet25(this, _WaitTask_world, "f").taskManager.delete(this);
    if (__classPrivateFieldGet25(this, _WaitTask_timeout, "f")) {
      clearTimeout(__classPrivateFieldGet25(this, _WaitTask_timeout, "f"));
    }
    if (error && !__classPrivateFieldGet25(this, _WaitTask_result, "f").finished()) {
      __classPrivateFieldGet25(this, _WaitTask_result, "f").reject(error);
    }
    if (__classPrivateFieldGet25(this, _WaitTask_poller, "f")) {
      try {
        await __classPrivateFieldGet25(this, _WaitTask_poller, "f").evaluateHandle(async (poller) => {
          await poller.stop();
        });
        if (__classPrivateFieldGet25(this, _WaitTask_poller, "f")) {
          await __classPrivateFieldGet25(this, _WaitTask_poller, "f").dispose();
          __classPrivateFieldSet21(this, _WaitTask_poller, void 0, "f");
        }
      } catch {
      }
    }
  }
  getBadError(error) {
    if (isErrorLike(error)) {
      if (error.message.includes("Execution context is not available in detached frame")) {
        return new Error("Waiting failed: Frame detached");
      }
      if (error.message.includes("Execution context was destroyed")) {
        return;
      }
      if (error.message.includes("Cannot find context with specified id")) {
        return;
      }
      return error;
    }
    return new Error("WaitTask failed with an error", {
      cause: error
    });
  }
};
_WaitTask_world = /* @__PURE__ */ new WeakMap(), _WaitTask_polling = /* @__PURE__ */ new WeakMap(), _WaitTask_root = /* @__PURE__ */ new WeakMap(), _WaitTask_fn = /* @__PURE__ */ new WeakMap(), _WaitTask_args = /* @__PURE__ */ new WeakMap(), _WaitTask_timeout = /* @__PURE__ */ new WeakMap(), _WaitTask_result = /* @__PURE__ */ new WeakMap(), _WaitTask_poller = /* @__PURE__ */ new WeakMap(), _WaitTask_signal = /* @__PURE__ */ new WeakMap();
var TaskManager = class {
  constructor() {
    _TaskManager_tasks.set(this, /* @__PURE__ */ new Set());
  }
  add(task) {
    __classPrivateFieldGet25(this, _TaskManager_tasks, "f").add(task);
  }
  delete(task) {
    __classPrivateFieldGet25(this, _TaskManager_tasks, "f").delete(task);
  }
  terminateAll(error) {
    for (const task of __classPrivateFieldGet25(this, _TaskManager_tasks, "f")) {
      void task.terminate(error);
    }
    __classPrivateFieldGet25(this, _TaskManager_tasks, "f").clear();
  }
  async rerunAll() {
    await Promise.all([...__classPrivateFieldGet25(this, _TaskManager_tasks, "f")].map((task) => {
      return task.rerun();
    }));
  }
};
_TaskManager_tasks = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/IsolatedWorld.js
var __classPrivateFieldGet26 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet22 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _IsolatedWorld_instances;
var _IsolatedWorld_frame;
var _IsolatedWorld_document;
var _IsolatedWorld_context;
var _IsolatedWorld_detached;
var _IsolatedWorld_contextBindings;
var _IsolatedWorld_bindings;
var _IsolatedWorld_taskManager;
var _IsolatedWorld_client_get;
var _IsolatedWorld_frameManager_get;
var _IsolatedWorld_timeoutSettings_get;
var _IsolatedWorld_mutex;
var _IsolatedWorld_onBindingCalled;
var _Mutex_locked;
var _Mutex_acquirers;
var IsolatedWorld = class {
  get taskManager() {
    return __classPrivateFieldGet26(this, _IsolatedWorld_taskManager, "f");
  }
  get _bindings() {
    return __classPrivateFieldGet26(this, _IsolatedWorld_bindings, "f");
  }
  constructor(frame) {
    _IsolatedWorld_instances.add(this);
    _IsolatedWorld_frame.set(this, void 0);
    _IsolatedWorld_document.set(this, void 0);
    _IsolatedWorld_context.set(this, Deferred.create());
    _IsolatedWorld_detached.set(this, false);
    _IsolatedWorld_contextBindings.set(this, /* @__PURE__ */ new Set());
    _IsolatedWorld_bindings.set(this, /* @__PURE__ */ new Map());
    _IsolatedWorld_taskManager.set(this, new TaskManager());
    _IsolatedWorld_mutex.set(this, new Mutex());
    _IsolatedWorld_onBindingCalled.set(this, async (event) => {
      let payload;
      try {
        payload = JSON.parse(event.payload);
      } catch {
        return;
      }
      const { type, name, seq, args, isTrivial } = payload;
      if (type !== "internal") {
        return;
      }
      if (!__classPrivateFieldGet26(this, _IsolatedWorld_contextBindings, "f").has(name)) {
        return;
      }
      try {
        const context = await __classPrivateFieldGet26(this, _IsolatedWorld_context, "f").valueOrThrow();
        if (event.executionContextId !== context._contextId) {
          return;
        }
        const binding = this._bindings.get(name);
        await (binding == null ? void 0 : binding.run(context, seq, args, isTrivial));
      } catch (err) {
        debugError(err);
      }
    });
    __classPrivateFieldSet22(this, _IsolatedWorld_frame, frame, "f");
    __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).on("Runtime.bindingCalled", __classPrivateFieldGet26(this, _IsolatedWorld_onBindingCalled, "f"));
  }
  frame() {
    return __classPrivateFieldGet26(this, _IsolatedWorld_frame, "f");
  }
  clearContext() {
    __classPrivateFieldSet22(this, _IsolatedWorld_document, void 0, "f");
    __classPrivateFieldSet22(this, _IsolatedWorld_context, Deferred.create(), "f");
  }
  setContext(context) {
    __classPrivateFieldGet26(this, _IsolatedWorld_contextBindings, "f").clear();
    __classPrivateFieldGet26(this, _IsolatedWorld_context, "f").resolve(context);
    void __classPrivateFieldGet26(this, _IsolatedWorld_taskManager, "f").rerunAll();
  }
  hasContext() {
    return __classPrivateFieldGet26(this, _IsolatedWorld_context, "f").resolved();
  }
  _detach() {
    __classPrivateFieldSet22(this, _IsolatedWorld_detached, true, "f");
    __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).off("Runtime.bindingCalled", __classPrivateFieldGet26(this, _IsolatedWorld_onBindingCalled, "f"));
    __classPrivateFieldGet26(this, _IsolatedWorld_taskManager, "f").terminateAll(new Error("waitForFunction failed: frame got detached."));
  }
  executionContext() {
    if (__classPrivateFieldGet26(this, _IsolatedWorld_detached, "f")) {
      throw new Error(`Execution context is not available in detached frame "${__classPrivateFieldGet26(this, _IsolatedWorld_frame, "f").url()}" (are you trying to evaluate?)`);
    }
    if (__classPrivateFieldGet26(this, _IsolatedWorld_context, "f") === null) {
      throw new Error(`Execution content promise is missing`);
    }
    return __classPrivateFieldGet26(this, _IsolatedWorld_context, "f").valueOrThrow();
  }
  async evaluateHandle(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
    const context = await this.executionContext();
    return context.evaluateHandle(pageFunction, ...args);
  }
  async evaluate(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
    const context = await this.executionContext();
    return context.evaluate(pageFunction, ...args);
  }
  async $(selector) {
    const document2 = await this.document();
    return document2.$(selector);
  }
  async $$(selector) {
    const document2 = await this.document();
    return document2.$$(selector);
  }
  async document() {
    if (__classPrivateFieldGet26(this, _IsolatedWorld_document, "f")) {
      return __classPrivateFieldGet26(this, _IsolatedWorld_document, "f");
    }
    const context = await this.executionContext();
    __classPrivateFieldSet22(this, _IsolatedWorld_document, await context.evaluateHandle(() => {
      return document;
    }), "f");
    return __classPrivateFieldGet26(this, _IsolatedWorld_document, "f");
  }
  async $x(expression) {
    const document2 = await this.document();
    return document2.$x(expression);
  }
  async $eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
    const document2 = await this.document();
    return document2.$eval(selector, pageFunction, ...args);
  }
  async $$eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
    const document2 = await this.document();
    return document2.$$eval(selector, pageFunction, ...args);
  }
  async content() {
    return await this.evaluate(getPageContent);
  }
  async setContent(html, options = {}) {
    const { waitUntil = ["load"], timeout = __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_timeoutSettings_get).navigationTimeout() } = options;
    await setPageContent(this, html);
    const watcher = new LifecycleWatcher(__classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_frameManager_get), __classPrivateFieldGet26(this, _IsolatedWorld_frame, "f"), waitUntil, timeout);
    const error = await Deferred.race([
      watcher.timeoutOrTerminationPromise(),
      watcher.lifecyclePromise()
    ]);
    watcher.dispose();
    if (error) {
      throw error;
    }
  }
  async click(selector, options) {
    const handle = await this.$(selector);
    assert(handle, `No element found for selector: ${selector}`);
    await handle.click(options);
    await handle.dispose();
  }
  async focus(selector) {
    const handle = await this.$(selector);
    assert(handle, `No element found for selector: ${selector}`);
    await handle.focus();
    await handle.dispose();
  }
  async hover(selector) {
    const handle = await this.$(selector);
    assert(handle, `No element found for selector: ${selector}`);
    await handle.hover();
    await handle.dispose();
  }
  async select(selector, ...values) {
    const handle = await this.$(selector);
    assert(handle, `No element found for selector: ${selector}`);
    const result = await handle.select(...values);
    await handle.dispose();
    return result;
  }
  async tap(selector) {
    const handle = await this.$(selector);
    assert(handle, `No element found for selector: ${selector}`);
    await handle.tap();
    await handle.dispose();
  }
  async type(selector, text, options) {
    const handle = await this.$(selector);
    assert(handle, `No element found for selector: ${selector}`);
    await handle.type(text, options);
    await handle.dispose();
  }
  async _addBindingToContext(context, name) {
    if (__classPrivateFieldGet26(this, _IsolatedWorld_contextBindings, "f").has(name)) {
      return;
    }
    await __classPrivateFieldGet26(this, _IsolatedWorld_mutex, "f").acquire();
    try {
      await context._client.send("Runtime.addBinding", context._contextName ? {
        name,
        executionContextName: context._contextName
      } : {
        name,
        executionContextId: context._contextId
      });
      await context.evaluate(addPageBinding, "internal", name);
      __classPrivateFieldGet26(this, _IsolatedWorld_contextBindings, "f").add(name);
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("Execution context was destroyed")) {
          return;
        }
        if (error.message.includes("Cannot find context with specified id")) {
          return;
        }
      }
      debugError(error);
    } finally {
      __classPrivateFieldGet26(this, _IsolatedWorld_mutex, "f").release();
    }
  }
  waitForFunction(pageFunction, options = {}, ...args) {
    const { polling = "raf", timeout = __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_timeoutSettings_get).timeout(), root, signal } = options;
    if (typeof polling === "number" && polling < 0) {
      throw new Error("Cannot poll with non-positive interval");
    }
    const waitTask = new WaitTask(this, {
      polling,
      root,
      timeout,
      signal
    }, pageFunction, ...args);
    return waitTask.result;
  }
  async title() {
    return this.evaluate(() => {
      return document.title;
    });
  }
  async adoptBackendNode(backendNodeId) {
    const executionContext = await this.executionContext();
    const { object } = await __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.resolveNode", {
      backendNodeId,
      executionContextId: executionContext._contextId
    });
    return createJSHandle(executionContext, object);
  }
  async adoptHandle(handle) {
    const context = await this.executionContext();
    assert(handle.executionContext() !== context, "Cannot adopt handle that already belongs to this execution context");
    const nodeInfo = await __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.describeNode", {
      objectId: handle.id
    });
    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
  }
  async transferHandle(handle) {
    const context = await this.executionContext();
    if (handle.executionContext() === context) {
      return handle;
    }
    const info = await __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_client_get).send("DOM.describeNode", {
      objectId: handle.remoteObject().objectId
    });
    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
    await handle.dispose();
    return newHandle;
  }
};
_IsolatedWorld_frame = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_document = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_context = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_detached = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_contextBindings = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_bindings = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_taskManager = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_mutex = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_onBindingCalled = /* @__PURE__ */ new WeakMap(), _IsolatedWorld_instances = /* @__PURE__ */ new WeakSet(), _IsolatedWorld_client_get = function _IsolatedWorld_client_get2() {
  return __classPrivateFieldGet26(this, _IsolatedWorld_frame, "f")._client();
}, _IsolatedWorld_frameManager_get = function _IsolatedWorld_frameManager_get2() {
  return __classPrivateFieldGet26(this, _IsolatedWorld_frame, "f")._frameManager;
}, _IsolatedWorld_timeoutSettings_get = function _IsolatedWorld_timeoutSettings_get2() {
  return __classPrivateFieldGet26(this, _IsolatedWorld_instances, "a", _IsolatedWorld_frameManager_get).timeoutSettings;
};
var Mutex = class {
  constructor() {
    _Mutex_locked.set(this, false);
    _Mutex_acquirers.set(this, []);
  }
  acquire() {
    if (!__classPrivateFieldGet26(this, _Mutex_locked, "f")) {
      __classPrivateFieldSet22(this, _Mutex_locked, true, "f");
      return Promise.resolve();
    }
    const deferred = Deferred.create();
    __classPrivateFieldGet26(this, _Mutex_acquirers, "f").push(deferred.resolve.bind(deferred));
    return deferred.valueOrThrow();
  }
  release() {
    const resolve = __classPrivateFieldGet26(this, _Mutex_acquirers, "f").shift();
    if (!resolve) {
      __classPrivateFieldSet22(this, _Mutex_locked, false, "f");
      return;
    }
    resolve();
  }
};
_Mutex_locked = /* @__PURE__ */ new WeakMap(), _Mutex_acquirers = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Frame.js
var __classPrivateFieldSet23 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet27 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Frame_url;
var _Frame_detached;
var _Frame_client;
var Frame2 = class extends Frame {
  constructor(frameManager, frameId, parentFrameId, client) {
    super();
    _Frame_url.set(this, "");
    _Frame_detached.set(this, false);
    _Frame_client.set(this, void 0);
    this._loaderId = "";
    this._hasStartedLoading = false;
    this._lifecycleEvents = /* @__PURE__ */ new Set();
    this._frameManager = frameManager;
    __classPrivateFieldSet23(this, _Frame_url, "", "f");
    this._id = frameId;
    this._parentId = parentFrameId;
    __classPrivateFieldSet23(this, _Frame_detached, false, "f");
    this._loaderId = "";
    this.updateClient(client);
  }
  updateClient(client) {
    __classPrivateFieldSet23(this, _Frame_client, client, "f");
    this.worlds = {
      [MAIN_WORLD]: new IsolatedWorld(this),
      [PUPPETEER_WORLD]: new IsolatedWorld(this)
    };
  }
  page() {
    return this._frameManager.page();
  }
  isOOPFrame() {
    return __classPrivateFieldGet27(this, _Frame_client, "f") !== this._frameManager.client;
  }
  async goto(url, options = {}) {
    const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout = this._frameManager.timeoutSettings.navigationTimeout() } = options;
    let ensureNewDocumentNavigation = false;
    const watcher = new LifecycleWatcher(this._frameManager, this, waitUntil, timeout);
    let error = await Deferred.race([
      navigate(__classPrivateFieldGet27(this, _Frame_client, "f"), url, referer, referrerPolicy, this._id),
      watcher.timeoutOrTerminationPromise()
    ]);
    if (!error) {
      error = await Deferred.race([
        watcher.timeoutOrTerminationPromise(),
        ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
      ]);
    }
    try {
      if (error) {
        throw error;
      }
      return await watcher.navigationResponse();
    } finally {
      watcher.dispose();
    }
    async function navigate(client, url2, referrer, referrerPolicy2, frameId) {
      try {
        const response = await client.send("Page.navigate", {
          url: url2,
          referrer,
          frameId,
          referrerPolicy: referrerPolicy2
        });
        ensureNewDocumentNavigation = !!response.loaderId;
        if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
          return null;
        }
        return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
      } catch (error2) {
        if (isErrorLike(error2)) {
          return error2;
        }
        throw error2;
      }
    }
  }
  async waitForNavigation(options = {}) {
    const { waitUntil = ["load"], timeout = this._frameManager.timeoutSettings.navigationTimeout() } = options;
    const watcher = new LifecycleWatcher(this._frameManager, this, waitUntil, timeout);
    const error = await Deferred.race([
      watcher.timeoutOrTerminationPromise(),
      watcher.sameDocumentNavigationPromise(),
      watcher.newDocumentNavigationPromise()
    ]);
    try {
      if (error) {
        throw error;
      }
      return await watcher.navigationResponse();
    } finally {
      watcher.dispose();
    }
  }
  _client() {
    return __classPrivateFieldGet27(this, _Frame_client, "f");
  }
  executionContext() {
    return this.worlds[MAIN_WORLD].executionContext();
  }
  mainRealm() {
    return this.worlds[MAIN_WORLD];
  }
  isolatedRealm() {
    return this.worlds[PUPPETEER_WORLD];
  }
  async evaluateHandle(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
    return this.mainRealm().evaluateHandle(pageFunction, ...args);
  }
  async evaluate(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
    return this.mainRealm().evaluate(pageFunction, ...args);
  }
  async $(selector) {
    return this.mainRealm().$(selector);
  }
  async $$(selector) {
    return this.mainRealm().$$(selector);
  }
  async $eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
    return this.mainRealm().$eval(selector, pageFunction, ...args);
  }
  async $$eval(selector, pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
    return this.mainRealm().$$eval(selector, pageFunction, ...args);
  }
  async $x(expression) {
    return this.mainRealm().$x(expression);
  }
  async content() {
    return this.isolatedRealm().content();
  }
  async setContent(html, options = {}) {
    return this.isolatedRealm().setContent(html, options);
  }
  name() {
    return this._name || "";
  }
  url() {
    return __classPrivateFieldGet27(this, _Frame_url, "f");
  }
  parentFrame() {
    return this._frameManager._frameTree.parentFrame(this._id) || null;
  }
  childFrames() {
    return this._frameManager._frameTree.childFrames(this._id);
  }
  isDetached() {
    return __classPrivateFieldGet27(this, _Frame_detached, "f");
  }
  async addScriptTag(options) {
    let { content = "", type } = options;
    const { path } = options;
    if (+!!options.url + +!!path + +!!content !== 1) {
      throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
    }
    if (path) {
      const fs2 = await importFSPromises();
      content = await fs2.readFile(path, "utf8");
      content += `//# sourceURL=${path.replace(/\n/g, "")}`;
    }
    type = type != null ? type : "text/javascript";
    return this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ Deferred: Deferred2 }, { url, id, type: type2, content: content2 }) => {
      const deferred = Deferred2.create();
      const script = document.createElement("script");
      script.type = type2;
      script.text = content2;
      if (url) {
        script.src = url;
        script.addEventListener("load", () => {
          return deferred.resolve();
        }, { once: true });
        script.addEventListener("error", (event) => {
          var _a2;
          deferred.reject(new Error((_a2 = event.message) != null ? _a2 : "Could not load script"));
        }, { once: true });
      } else {
        deferred.resolve();
      }
      if (id) {
        script.id = id;
      }
      document.head.appendChild(script);
      await deferred.valueOrThrow();
      return script;
    }, LazyArg.create((context) => {
      return context.puppeteerUtil;
    }), { ...options, type, content }));
  }
  async addStyleTag(options) {
    let { content = "" } = options;
    const { path } = options;
    if (+!!options.url + +!!path + +!!content !== 1) {
      throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
    }
    if (path) {
      const fs2 = await importFSPromises();
      content = await fs2.readFile(path, "utf8");
      content += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
      options.content = content;
    }
    return this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ Deferred: Deferred2 }, { url, content: content2 }) => {
      const deferred = Deferred2.create();
      let element;
      if (!url) {
        element = document.createElement("style");
        element.appendChild(document.createTextNode(content2));
      } else {
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = url;
        element = link;
      }
      element.addEventListener("load", () => {
        deferred.resolve();
      }, { once: true });
      element.addEventListener("error", (event) => {
        var _a2;
        deferred.reject(new Error((_a2 = event.message) != null ? _a2 : "Could not load style"));
      }, { once: true });
      document.head.appendChild(element);
      await deferred.valueOrThrow();
      return element;
    }, LazyArg.create((context) => {
      return context.puppeteerUtil;
    }), options));
  }
  async title() {
    return this.isolatedRealm().title();
  }
  _deviceRequestPromptManager() {
    if (this.isOOPFrame()) {
      return this._frameManager._deviceRequestPromptManager(__classPrivateFieldGet27(this, _Frame_client, "f"));
    }
    const parentFrame = this.parentFrame();
    assert(parentFrame !== null);
    return parentFrame._deviceRequestPromptManager();
  }
  waitForDevicePrompt(options = {}) {
    return this._deviceRequestPromptManager().waitForDevicePrompt(options);
  }
  _navigated(framePayload) {
    this._name = framePayload.name;
    __classPrivateFieldSet23(this, _Frame_url, `${framePayload.url}${framePayload.urlFragment || ""}`, "f");
  }
  _navigatedWithinDocument(url) {
    __classPrivateFieldSet23(this, _Frame_url, url, "f");
  }
  _onLifecycleEvent(loaderId, name) {
    if (name === "init") {
      this._loaderId = loaderId;
      this._lifecycleEvents.clear();
    }
    this._lifecycleEvents.add(name);
  }
  _onLoadingStopped() {
    this._lifecycleEvents.add("DOMContentLoaded");
    this._lifecycleEvents.add("load");
  }
  _onLoadingStarted() {
    this._hasStartedLoading = true;
  }
  _detach() {
    __classPrivateFieldSet23(this, _Frame_detached, true, "f");
    this.worlds[MAIN_WORLD]._detach();
    this.worlds[PUPPETEER_WORLD]._detach();
  }
};
_Frame_url = /* @__PURE__ */ new WeakMap(), _Frame_detached = /* @__PURE__ */ new WeakMap(), _Frame_client = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/FrameTree.js
var __classPrivateFieldGet28 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet24 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _FrameTree_frames;
var _FrameTree_parentIds;
var _FrameTree_childIds;
var _FrameTree_mainFrame;
var _FrameTree_waitRequests;
var FrameTree = class {
  constructor() {
    _FrameTree_frames.set(this, /* @__PURE__ */ new Map());
    _FrameTree_parentIds.set(this, /* @__PURE__ */ new Map());
    _FrameTree_childIds.set(this, /* @__PURE__ */ new Map());
    _FrameTree_mainFrame.set(this, void 0);
    _FrameTree_waitRequests.set(this, /* @__PURE__ */ new Map());
  }
  getMainFrame() {
    return __classPrivateFieldGet28(this, _FrameTree_mainFrame, "f");
  }
  getById(frameId) {
    return __classPrivateFieldGet28(this, _FrameTree_frames, "f").get(frameId);
  }
  waitForFrame(frameId) {
    const frame = this.getById(frameId);
    if (frame) {
      return Promise.resolve(frame);
    }
    const deferred = Deferred.create();
    const callbacks = __classPrivateFieldGet28(this, _FrameTree_waitRequests, "f").get(frameId) || /* @__PURE__ */ new Set();
    callbacks.add(deferred);
    return deferred.valueOrThrow();
  }
  frames() {
    return Array.from(__classPrivateFieldGet28(this, _FrameTree_frames, "f").values());
  }
  addFrame(frame) {
    var _a2;
    __classPrivateFieldGet28(this, _FrameTree_frames, "f").set(frame._id, frame);
    if (frame._parentId) {
      __classPrivateFieldGet28(this, _FrameTree_parentIds, "f").set(frame._id, frame._parentId);
      if (!__classPrivateFieldGet28(this, _FrameTree_childIds, "f").has(frame._parentId)) {
        __classPrivateFieldGet28(this, _FrameTree_childIds, "f").set(frame._parentId, /* @__PURE__ */ new Set());
      }
      __classPrivateFieldGet28(this, _FrameTree_childIds, "f").get(frame._parentId).add(frame._id);
    } else {
      __classPrivateFieldSet24(this, _FrameTree_mainFrame, frame, "f");
    }
    (_a2 = __classPrivateFieldGet28(this, _FrameTree_waitRequests, "f").get(frame._id)) == null ? void 0 : _a2.forEach((request) => {
      return request.resolve(frame);
    });
  }
  removeFrame(frame) {
    var _a2;
    __classPrivateFieldGet28(this, _FrameTree_frames, "f").delete(frame._id);
    __classPrivateFieldGet28(this, _FrameTree_parentIds, "f").delete(frame._id);
    if (frame._parentId) {
      (_a2 = __classPrivateFieldGet28(this, _FrameTree_childIds, "f").get(frame._parentId)) == null ? void 0 : _a2.delete(frame._id);
    } else {
      __classPrivateFieldSet24(this, _FrameTree_mainFrame, void 0, "f");
    }
  }
  childFrames(frameId) {
    const childIds = __classPrivateFieldGet28(this, _FrameTree_childIds, "f").get(frameId);
    if (!childIds) {
      return [];
    }
    return Array.from(childIds).map((id) => {
      return this.getById(id);
    }).filter((frame) => {
      return frame !== void 0;
    });
  }
  parentFrame(frameId) {
    const parentId = __classPrivateFieldGet28(this, _FrameTree_parentIds, "f").get(frameId);
    return parentId ? this.getById(parentId) : void 0;
  }
};
_FrameTree_frames = /* @__PURE__ */ new WeakMap(), _FrameTree_parentIds = /* @__PURE__ */ new WeakMap(), _FrameTree_childIds = /* @__PURE__ */ new WeakMap(), _FrameTree_mainFrame = /* @__PURE__ */ new WeakMap(), _FrameTree_waitRequests = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/FrameManager.js
var __classPrivateFieldGet29 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet25 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _FrameManager_instances;
var _FrameManager_page;
var _FrameManager_networkManager;
var _FrameManager_timeoutSettings;
var _FrameManager_contextIdToContext;
var _FrameManager_isolatedWorlds;
var _FrameManager_client;
var _FrameManager_frameNavigatedReceived;
var _FrameManager_deviceRequestPromptManagerMap;
var _FrameManager_onLifecycleEvent;
var _FrameManager_onFrameStartedLoading;
var _FrameManager_onFrameStoppedLoading;
var _FrameManager_handleFrameTree;
var _FrameManager_onFrameAttached;
var _FrameManager_onFrameNavigated;
var _FrameManager_createIsolatedWorld;
var _FrameManager_onFrameNavigatedWithinDocument;
var _FrameManager_onFrameDetached;
var _FrameManager_onExecutionContextCreated;
var _FrameManager_onExecutionContextDestroyed;
var _FrameManager_onExecutionContextsCleared;
var _FrameManager_removeFramesRecursively;
var UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
var FrameManagerEmittedEvents = {
  FrameAttached: Symbol("FrameManager.FrameAttached"),
  FrameNavigated: Symbol("FrameManager.FrameNavigated"),
  FrameDetached: Symbol("FrameManager.FrameDetached"),
  FrameSwapped: Symbol("FrameManager.FrameSwapped"),
  LifecycleEvent: Symbol("FrameManager.LifecycleEvent"),
  FrameNavigatedWithinDocument: Symbol("FrameManager.FrameNavigatedWithinDocument"),
  ExecutionContextCreated: Symbol("FrameManager.ExecutionContextCreated"),
  ExecutionContextDestroyed: Symbol("FrameManager.ExecutionContextDestroyed")
};
var FrameManager = class extends EventEmitter {
  get timeoutSettings() {
    return __classPrivateFieldGet29(this, _FrameManager_timeoutSettings, "f");
  }
  get networkManager() {
    return __classPrivateFieldGet29(this, _FrameManager_networkManager, "f");
  }
  get client() {
    return __classPrivateFieldGet29(this, _FrameManager_client, "f");
  }
  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
    super();
    _FrameManager_instances.add(this);
    _FrameManager_page.set(this, void 0);
    _FrameManager_networkManager.set(this, void 0);
    _FrameManager_timeoutSettings.set(this, void 0);
    _FrameManager_contextIdToContext.set(this, /* @__PURE__ */ new Map());
    _FrameManager_isolatedWorlds.set(this, /* @__PURE__ */ new Set());
    _FrameManager_client.set(this, void 0);
    this._frameTree = new FrameTree();
    _FrameManager_frameNavigatedReceived.set(this, /* @__PURE__ */ new Set());
    _FrameManager_deviceRequestPromptManagerMap.set(this, /* @__PURE__ */ new WeakMap());
    __classPrivateFieldSet25(this, _FrameManager_client, client, "f");
    __classPrivateFieldSet25(this, _FrameManager_page, page, "f");
    __classPrivateFieldSet25(this, _FrameManager_networkManager, new NetworkManager(client, ignoreHTTPSErrors, this), "f");
    __classPrivateFieldSet25(this, _FrameManager_timeoutSettings, timeoutSettings, "f");
    this.setupEventListeners(__classPrivateFieldGet29(this, _FrameManager_client, "f"));
  }
  setupEventListeners(session) {
    session.on("Page.frameAttached", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameAttached).call(this, session, event.frameId, event.parentFrameId);
    });
    session.on("Page.frameNavigated", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_frameNavigatedReceived, "f").add(event.frame.id);
      void __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigated).call(this, event.frame);
    });
    session.on("Page.navigatedWithinDocument", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigatedWithinDocument).call(this, event.frameId, event.url);
    });
    session.on("Page.frameDetached", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameDetached).call(this, event.frameId, event.reason);
    });
    session.on("Page.frameStartedLoading", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameStartedLoading).call(this, event.frameId);
    });
    session.on("Page.frameStoppedLoading", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameStoppedLoading).call(this, event.frameId);
    });
    session.on("Runtime.executionContextCreated", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextCreated).call(this, event.context, session);
    });
    session.on("Runtime.executionContextDestroyed", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextDestroyed).call(this, event.executionContextId, session);
    });
    session.on("Runtime.executionContextsCleared", () => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onExecutionContextsCleared).call(this, session);
    });
    session.on("Page.lifecycleEvent", (event) => {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onLifecycleEvent).call(this, event);
    });
  }
  async initialize(client = __classPrivateFieldGet29(this, _FrameManager_client, "f")) {
    try {
      const result = await Promise.all([
        client.send("Page.enable"),
        client.send("Page.getFrameTree")
      ]);
      const { frameTree } = result[1];
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_handleFrameTree).call(this, client, frameTree);
      await Promise.all([
        client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
        client.send("Runtime.enable").then(() => {
          return __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_createIsolatedWorld).call(this, client, UTILITY_WORLD_NAME);
        }),
        client === __classPrivateFieldGet29(this, _FrameManager_client, "f") ? __classPrivateFieldGet29(this, _FrameManager_networkManager, "f").initialize() : Promise.resolve()
      ]);
    } catch (error) {
      if (isErrorLike(error) && isTargetClosedError(error)) {
        return;
      }
      throw error;
    }
  }
  executionContextById(contextId, session = __classPrivateFieldGet29(this, _FrameManager_client, "f")) {
    const context = this.getExecutionContextById(contextId, session);
    assert(context, "INTERNAL ERROR: missing context with id = " + contextId);
    return context;
  }
  getExecutionContextById(contextId, session = __classPrivateFieldGet29(this, _FrameManager_client, "f")) {
    return __classPrivateFieldGet29(this, _FrameManager_contextIdToContext, "f").get(`${session.id()}:${contextId}`);
  }
  page() {
    return __classPrivateFieldGet29(this, _FrameManager_page, "f");
  }
  mainFrame() {
    const mainFrame = this._frameTree.getMainFrame();
    assert(mainFrame, "Requesting main frame too early!");
    return mainFrame;
  }
  frames() {
    return Array.from(this._frameTree.frames());
  }
  frame(frameId) {
    return this._frameTree.getById(frameId) || null;
  }
  onAttachedToTarget(target) {
    if (target._getTargetInfo().type !== "iframe") {
      return;
    }
    const frame = this.frame(target._getTargetInfo().targetId);
    if (frame) {
      frame.updateClient(target._session());
    }
    this.setupEventListeners(target._session());
    void this.initialize(target._session());
  }
  _deviceRequestPromptManager(client) {
    let manager = __classPrivateFieldGet29(this, _FrameManager_deviceRequestPromptManagerMap, "f").get(client);
    if (manager === void 0) {
      manager = new DeviceRequestPromptManager(client, __classPrivateFieldGet29(this, _FrameManager_timeoutSettings, "f"));
      __classPrivateFieldGet29(this, _FrameManager_deviceRequestPromptManagerMap, "f").set(client, manager);
    }
    return manager;
  }
};
_FrameManager_page = /* @__PURE__ */ new WeakMap(), _FrameManager_networkManager = /* @__PURE__ */ new WeakMap(), _FrameManager_timeoutSettings = /* @__PURE__ */ new WeakMap(), _FrameManager_contextIdToContext = /* @__PURE__ */ new WeakMap(), _FrameManager_isolatedWorlds = /* @__PURE__ */ new WeakMap(), _FrameManager_client = /* @__PURE__ */ new WeakMap(), _FrameManager_frameNavigatedReceived = /* @__PURE__ */ new WeakMap(), _FrameManager_deviceRequestPromptManagerMap = /* @__PURE__ */ new WeakMap(), _FrameManager_instances = /* @__PURE__ */ new WeakSet(), _FrameManager_onLifecycleEvent = function _FrameManager_onLifecycleEvent2(event) {
  const frame = this.frame(event.frameId);
  if (!frame) {
    return;
  }
  frame._onLifecycleEvent(event.loaderId, event.name);
  this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);
}, _FrameManager_onFrameStartedLoading = function _FrameManager_onFrameStartedLoading2(frameId) {
  const frame = this.frame(frameId);
  if (!frame) {
    return;
  }
  frame._onLoadingStarted();
}, _FrameManager_onFrameStoppedLoading = function _FrameManager_onFrameStoppedLoading2(frameId) {
  const frame = this.frame(frameId);
  if (!frame) {
    return;
  }
  frame._onLoadingStopped();
  this.emit(FrameManagerEmittedEvents.LifecycleEvent, frame);
}, _FrameManager_handleFrameTree = function _FrameManager_handleFrameTree2(session, frameTree) {
  if (frameTree.frame.parentId) {
    __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameAttached).call(this, session, frameTree.frame.id, frameTree.frame.parentId);
  }
  if (!__classPrivateFieldGet29(this, _FrameManager_frameNavigatedReceived, "f").has(frameTree.frame.id)) {
    void __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_onFrameNavigated).call(this, frameTree.frame);
  } else {
    __classPrivateFieldGet29(this, _FrameManager_frameNavigatedReceived, "f").delete(frameTree.frame.id);
  }
  if (!frameTree.childFrames) {
    return;
  }
  for (const child of frameTree.childFrames) {
    __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_handleFrameTree2).call(this, session, child);
  }
}, _FrameManager_onFrameAttached = function _FrameManager_onFrameAttached2(session, frameId, parentFrameId) {
  let frame = this.frame(frameId);
  if (frame) {
    if (session && frame.isOOPFrame()) {
      frame.updateClient(session);
    }
    return;
  }
  frame = new Frame2(this, frameId, parentFrameId, session);
  this._frameTree.addFrame(frame);
  this.emit(FrameManagerEmittedEvents.FrameAttached, frame);
}, _FrameManager_onFrameNavigated = async function _FrameManager_onFrameNavigated2(framePayload) {
  const frameId = framePayload.id;
  const isMainFrame = !framePayload.parentId;
  let frame = this._frameTree.getById(frameId);
  if (frame) {
    for (const child of frame.childFrames()) {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, child);
    }
  }
  if (isMainFrame) {
    if (frame) {
      this._frameTree.removeFrame(frame);
      frame._id = frameId;
    } else {
      frame = new Frame2(this, frameId, void 0, __classPrivateFieldGet29(this, _FrameManager_client, "f"));
    }
    this._frameTree.addFrame(frame);
  }
  frame = await this._frameTree.waitForFrame(frameId);
  frame._navigated(framePayload);
  this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);
}, _FrameManager_createIsolatedWorld = async function _FrameManager_createIsolatedWorld2(session, name) {
  const key = `${session.id()}:${name}`;
  if (__classPrivateFieldGet29(this, _FrameManager_isolatedWorlds, "f").has(key)) {
    return;
  }
  await session.send("Page.addScriptToEvaluateOnNewDocument", {
    source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
    worldName: name
  });
  await Promise.all(this.frames().filter((frame) => {
    return frame._client() === session;
  }).map((frame) => {
    return session.send("Page.createIsolatedWorld", {
      frameId: frame._id,
      worldName: name,
      grantUniveralAccess: true
    }).catch(debugError);
  }));
  __classPrivateFieldGet29(this, _FrameManager_isolatedWorlds, "f").add(key);
}, _FrameManager_onFrameNavigatedWithinDocument = function _FrameManager_onFrameNavigatedWithinDocument2(frameId, url) {
  const frame = this.frame(frameId);
  if (!frame) {
    return;
  }
  frame._navigatedWithinDocument(url);
  this.emit(FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);
  this.emit(FrameManagerEmittedEvents.FrameNavigated, frame);
}, _FrameManager_onFrameDetached = function _FrameManager_onFrameDetached2(frameId, reason) {
  const frame = this.frame(frameId);
  if (reason === "remove") {
    if (frame) {
      __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively).call(this, frame);
    }
  } else if (reason === "swap") {
    this.emit(FrameManagerEmittedEvents.FrameSwapped, frame);
  }
}, _FrameManager_onExecutionContextCreated = function _FrameManager_onExecutionContextCreated2(contextPayload, session) {
  const auxData = contextPayload.auxData;
  const frameId = auxData && auxData.frameId;
  const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
  let world;
  if (frame) {
    if (frame._client() !== session) {
      return;
    }
    if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
      world = frame.worlds[MAIN_WORLD];
    } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[PUPPETEER_WORLD].hasContext()) {
      world = frame.worlds[PUPPETEER_WORLD];
    }
  }
  const context = new ExecutionContext((frame == null ? void 0 : frame._client()) || __classPrivateFieldGet29(this, _FrameManager_client, "f"), contextPayload, world);
  if (world) {
    world.setContext(context);
  }
  const key = `${session.id()}:${contextPayload.id}`;
  __classPrivateFieldGet29(this, _FrameManager_contextIdToContext, "f").set(key, context);
}, _FrameManager_onExecutionContextDestroyed = function _FrameManager_onExecutionContextDestroyed2(executionContextId, session) {
  const key = `${session.id()}:${executionContextId}`;
  const context = __classPrivateFieldGet29(this, _FrameManager_contextIdToContext, "f").get(key);
  if (!context) {
    return;
  }
  __classPrivateFieldGet29(this, _FrameManager_contextIdToContext, "f").delete(key);
  if (context._world) {
    context._world.clearContext();
  }
}, _FrameManager_onExecutionContextsCleared = function _FrameManager_onExecutionContextsCleared2(session) {
  for (const [key, context] of __classPrivateFieldGet29(this, _FrameManager_contextIdToContext, "f").entries()) {
    if (context._client !== session) {
      continue;
    }
    if (context._world) {
      context._world.clearContext();
    }
    __classPrivateFieldGet29(this, _FrameManager_contextIdToContext, "f").delete(key);
  }
}, _FrameManager_removeFramesRecursively = function _FrameManager_removeFramesRecursively2(frame) {
  for (const child of frame.childFrames()) {
    __classPrivateFieldGet29(this, _FrameManager_instances, "m", _FrameManager_removeFramesRecursively2).call(this, child);
  }
  frame._detach();
  this._frameTree.removeFrame(frame);
  this.emit(FrameManagerEmittedEvents.FrameDetached, frame);
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/LifecycleWatcher.js
var __classPrivateFieldSet26 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet30 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LifecycleWatcher_instances;
var _LifecycleWatcher_expectedLifecycle;
var _LifecycleWatcher_frameManager;
var _LifecycleWatcher_frame;
var _LifecycleWatcher_timeout;
var _LifecycleWatcher_navigationRequest;
var _LifecycleWatcher_eventListeners;
var _LifecycleWatcher_initialLoaderId;
var _LifecycleWatcher_sameDocumentNavigationDeferred;
var _LifecycleWatcher_lifecycleDeferred;
var _LifecycleWatcher_newDocumentNavigationDeferred;
var _LifecycleWatcher_terminationDeferred;
var _LifecycleWatcher_timeoutPromise;
var _LifecycleWatcher_maximumTimer;
var _LifecycleWatcher_hasSameDocumentNavigation;
var _LifecycleWatcher_swapped;
var _LifecycleWatcher_navigationResponseReceived;
var _LifecycleWatcher_onRequest;
var _LifecycleWatcher_onRequestFailed;
var _LifecycleWatcher_onResponse;
var _LifecycleWatcher_onFrameDetached;
var _LifecycleWatcher_terminate;
var _LifecycleWatcher_createTimeoutPromise;
var _LifecycleWatcher_navigatedWithinDocument;
var _LifecycleWatcher_navigated;
var _LifecycleWatcher_frameSwapped;
var _LifecycleWatcher_checkLifecycleComplete;
var puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
  ["load", "load"],
  ["domcontentloaded", "DOMContentLoaded"],
  ["networkidle0", "networkIdle"],
  ["networkidle2", "networkAlmostIdle"]
]);
var noop = () => {
};
var LifecycleWatcher = class {
  constructor(frameManager, frame, waitUntil, timeout) {
    _LifecycleWatcher_instances.add(this);
    _LifecycleWatcher_expectedLifecycle.set(this, void 0);
    _LifecycleWatcher_frameManager.set(this, void 0);
    _LifecycleWatcher_frame.set(this, void 0);
    _LifecycleWatcher_timeout.set(this, void 0);
    _LifecycleWatcher_navigationRequest.set(this, null);
    _LifecycleWatcher_eventListeners.set(this, void 0);
    _LifecycleWatcher_initialLoaderId.set(this, void 0);
    _LifecycleWatcher_sameDocumentNavigationDeferred.set(this, Deferred.create());
    _LifecycleWatcher_lifecycleDeferred.set(this, Deferred.create());
    _LifecycleWatcher_newDocumentNavigationDeferred.set(this, Deferred.create());
    _LifecycleWatcher_terminationDeferred.set(this, Deferred.create());
    _LifecycleWatcher_timeoutPromise.set(this, void 0);
    _LifecycleWatcher_maximumTimer.set(this, void 0);
    _LifecycleWatcher_hasSameDocumentNavigation.set(this, void 0);
    _LifecycleWatcher_swapped.set(this, void 0);
    _LifecycleWatcher_navigationResponseReceived.set(this, void 0);
    if (Array.isArray(waitUntil)) {
      waitUntil = waitUntil.slice();
    } else if (typeof waitUntil === "string") {
      waitUntil = [waitUntil];
    }
    __classPrivateFieldSet26(this, _LifecycleWatcher_initialLoaderId, frame._loaderId, "f");
    __classPrivateFieldSet26(this, _LifecycleWatcher_expectedLifecycle, waitUntil.map((value) => {
      const protocolEvent = puppeteerToProtocolLifecycle.get(value);
      assert(protocolEvent, "Unknown value for options.waitUntil: " + value);
      return protocolEvent;
    }), "f");
    __classPrivateFieldSet26(this, _LifecycleWatcher_frameManager, frameManager, "f");
    __classPrivateFieldSet26(this, _LifecycleWatcher_frame, frame, "f");
    __classPrivateFieldSet26(this, _LifecycleWatcher_timeout, timeout, "f");
    __classPrivateFieldSet26(this, _LifecycleWatcher_eventListeners, [
      addEventListener(frameManager.client, CDPSessionEmittedEvents.Disconnected, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_terminate).bind(this, new Error("Navigation failed because browser has disconnected!"))),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f"), FrameManagerEmittedEvents.LifecycleEvent, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).bind(this)),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f"), FrameManagerEmittedEvents.FrameNavigatedWithinDocument, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_navigatedWithinDocument).bind(this)),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f"), FrameManagerEmittedEvents.FrameNavigated, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_navigated).bind(this)),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f"), FrameManagerEmittedEvents.FrameSwapped, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_frameSwapped).bind(this)),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f"), FrameManagerEmittedEvents.FrameDetached, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onFrameDetached).bind(this)),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManagerEmittedEvents.Request, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onRequest).bind(this)),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManagerEmittedEvents.Response, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onResponse).bind(this)),
      addEventListener(__classPrivateFieldGet30(this, _LifecycleWatcher_frameManager, "f").networkManager, NetworkManagerEmittedEvents.RequestFailed, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_onRequestFailed).bind(this))
    ], "f");
    __classPrivateFieldSet26(this, _LifecycleWatcher_timeoutPromise, __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_createTimeoutPromise).call(this), "f");
    __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
  }
  async navigationResponse() {
    var _a2;
    await ((_a2 = __classPrivateFieldGet30(this, _LifecycleWatcher_navigationResponseReceived, "f")) == null ? void 0 : _a2.valueOrThrow());
    return __classPrivateFieldGet30(this, _LifecycleWatcher_navigationRequest, "f") ? __classPrivateFieldGet30(this, _LifecycleWatcher_navigationRequest, "f").response() : null;
  }
  sameDocumentNavigationPromise() {
    return __classPrivateFieldGet30(this, _LifecycleWatcher_sameDocumentNavigationDeferred, "f").valueOrThrow();
  }
  newDocumentNavigationPromise() {
    return __classPrivateFieldGet30(this, _LifecycleWatcher_newDocumentNavigationDeferred, "f").valueOrThrow();
  }
  lifecyclePromise() {
    return __classPrivateFieldGet30(this, _LifecycleWatcher_lifecycleDeferred, "f").valueOrThrow();
  }
  timeoutOrTerminationPromise() {
    return Deferred.race([__classPrivateFieldGet30(this, _LifecycleWatcher_timeoutPromise, "f"), __classPrivateFieldGet30(this, _LifecycleWatcher_terminationDeferred, "f")]);
  }
  dispose() {
    removeEventListeners(__classPrivateFieldGet30(this, _LifecycleWatcher_eventListeners, "f"));
    clearTimeout(__classPrivateFieldGet30(this, _LifecycleWatcher_maximumTimer, "f"));
  }
};
_LifecycleWatcher_expectedLifecycle = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_frameManager = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_frame = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_timeout = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_navigationRequest = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_eventListeners = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_initialLoaderId = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_sameDocumentNavigationDeferred = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_lifecycleDeferred = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_newDocumentNavigationDeferred = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_terminationDeferred = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_timeoutPromise = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_maximumTimer = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_hasSameDocumentNavigation = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_swapped = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_navigationResponseReceived = /* @__PURE__ */ new WeakMap(), _LifecycleWatcher_instances = /* @__PURE__ */ new WeakSet(), _LifecycleWatcher_onRequest = function _LifecycleWatcher_onRequest2(request) {
  var _a2, _b;
  if (request.frame() !== __classPrivateFieldGet30(this, _LifecycleWatcher_frame, "f") || !request.isNavigationRequest()) {
    return;
  }
  __classPrivateFieldSet26(this, _LifecycleWatcher_navigationRequest, request, "f");
  (_a2 = __classPrivateFieldGet30(this, _LifecycleWatcher_navigationResponseReceived, "f")) == null ? void 0 : _a2.resolve();
  __classPrivateFieldSet26(this, _LifecycleWatcher_navigationResponseReceived, Deferred.create(), "f");
  if (request.response() !== null) {
    (_b = __classPrivateFieldGet30(this, _LifecycleWatcher_navigationResponseReceived, "f")) == null ? void 0 : _b.resolve();
  }
}, _LifecycleWatcher_onRequestFailed = function _LifecycleWatcher_onRequestFailed2(request) {
  var _a2, _b;
  if (((_a2 = __classPrivateFieldGet30(this, _LifecycleWatcher_navigationRequest, "f")) == null ? void 0 : _a2._requestId) !== request._requestId) {
    return;
  }
  (_b = __classPrivateFieldGet30(this, _LifecycleWatcher_navigationResponseReceived, "f")) == null ? void 0 : _b.resolve();
}, _LifecycleWatcher_onResponse = function _LifecycleWatcher_onResponse2(response) {
  var _a2, _b;
  if (((_a2 = __classPrivateFieldGet30(this, _LifecycleWatcher_navigationRequest, "f")) == null ? void 0 : _a2._requestId) !== response.request()._requestId) {
    return;
  }
  (_b = __classPrivateFieldGet30(this, _LifecycleWatcher_navigationResponseReceived, "f")) == null ? void 0 : _b.resolve();
}, _LifecycleWatcher_onFrameDetached = function _LifecycleWatcher_onFrameDetached2(frame) {
  if (__classPrivateFieldGet30(this, _LifecycleWatcher_frame, "f") === frame) {
    __classPrivateFieldGet30(this, _LifecycleWatcher_terminationDeferred, "f").resolve(new Error("Navigating frame was detached"));
    return;
  }
  __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
}, _LifecycleWatcher_terminate = function _LifecycleWatcher_terminate2(error) {
  __classPrivateFieldGet30(this, _LifecycleWatcher_terminationDeferred, "f").resolve(error);
}, _LifecycleWatcher_createTimeoutPromise = async function _LifecycleWatcher_createTimeoutPromise2() {
  if (!__classPrivateFieldGet30(this, _LifecycleWatcher_timeout, "f")) {
    return new Promise(noop);
  }
  const errorMessage = "Navigation timeout of " + __classPrivateFieldGet30(this, _LifecycleWatcher_timeout, "f") + " ms exceeded";
  await new Promise((fulfill) => {
    return __classPrivateFieldSet26(this, _LifecycleWatcher_maximumTimer, setTimeout(fulfill, __classPrivateFieldGet30(this, _LifecycleWatcher_timeout, "f")), "f");
  });
  return new TimeoutError(errorMessage);
}, _LifecycleWatcher_navigatedWithinDocument = function _LifecycleWatcher_navigatedWithinDocument2(frame) {
  if (frame !== __classPrivateFieldGet30(this, _LifecycleWatcher_frame, "f")) {
    return;
  }
  __classPrivateFieldSet26(this, _LifecycleWatcher_hasSameDocumentNavigation, true, "f");
  __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
}, _LifecycleWatcher_navigated = function _LifecycleWatcher_navigated2(frame) {
  if (frame !== __classPrivateFieldGet30(this, _LifecycleWatcher_frame, "f")) {
    return;
  }
  __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
}, _LifecycleWatcher_frameSwapped = function _LifecycleWatcher_frameSwapped2(frame) {
  if (frame !== __classPrivateFieldGet30(this, _LifecycleWatcher_frame, "f")) {
    return;
  }
  __classPrivateFieldSet26(this, _LifecycleWatcher_swapped, true, "f");
  __classPrivateFieldGet30(this, _LifecycleWatcher_instances, "m", _LifecycleWatcher_checkLifecycleComplete).call(this);
}, _LifecycleWatcher_checkLifecycleComplete = function _LifecycleWatcher_checkLifecycleComplete2() {
  if (!checkLifecycle(__classPrivateFieldGet30(this, _LifecycleWatcher_frame, "f"), __classPrivateFieldGet30(this, _LifecycleWatcher_expectedLifecycle, "f"))) {
    return;
  }
  __classPrivateFieldGet30(this, _LifecycleWatcher_lifecycleDeferred, "f").resolve();
  if (__classPrivateFieldGet30(this, _LifecycleWatcher_hasSameDocumentNavigation, "f")) {
    __classPrivateFieldGet30(this, _LifecycleWatcher_sameDocumentNavigationDeferred, "f").resolve(void 0);
  }
  if (__classPrivateFieldGet30(this, _LifecycleWatcher_swapped, "f") || __classPrivateFieldGet30(this, _LifecycleWatcher_frame, "f")._loaderId !== __classPrivateFieldGet30(this, _LifecycleWatcher_initialLoaderId, "f")) {
    __classPrivateFieldGet30(this, _LifecycleWatcher_newDocumentNavigationDeferred, "f").resolve(void 0);
  }
  function checkLifecycle(frame, expectedLifecycle) {
    for (const event of expectedLifecycle) {
      if (!frame._lifecycleEvents.has(event)) {
        return false;
      }
    }
    for (const child of frame.childFrames()) {
      if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js
var __classPrivateFieldSet27 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet31 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TimeoutSettings_defaultTimeout;
var _TimeoutSettings_defaultNavigationTimeout;
var DEFAULT_TIMEOUT = 3e4;
var TimeoutSettings = class {
  constructor() {
    _TimeoutSettings_defaultTimeout.set(this, void 0);
    _TimeoutSettings_defaultNavigationTimeout.set(this, void 0);
    __classPrivateFieldSet27(this, _TimeoutSettings_defaultTimeout, null, "f");
    __classPrivateFieldSet27(this, _TimeoutSettings_defaultNavigationTimeout, null, "f");
  }
  setDefaultTimeout(timeout) {
    __classPrivateFieldSet27(this, _TimeoutSettings_defaultTimeout, timeout, "f");
  }
  setDefaultNavigationTimeout(timeout) {
    __classPrivateFieldSet27(this, _TimeoutSettings_defaultNavigationTimeout, timeout, "f");
  }
  navigationTimeout() {
    if (__classPrivateFieldGet31(this, _TimeoutSettings_defaultNavigationTimeout, "f") !== null) {
      return __classPrivateFieldGet31(this, _TimeoutSettings_defaultNavigationTimeout, "f");
    }
    if (__classPrivateFieldGet31(this, _TimeoutSettings_defaultTimeout, "f") !== null) {
      return __classPrivateFieldGet31(this, _TimeoutSettings_defaultTimeout, "f");
    }
    return DEFAULT_TIMEOUT;
  }
  timeout() {
    if (__classPrivateFieldGet31(this, _TimeoutSettings_defaultTimeout, "f") !== null) {
      return __classPrivateFieldGet31(this, _TimeoutSettings_defaultTimeout, "f");
    }
    return DEFAULT_TIMEOUT;
  }
};
_TimeoutSettings_defaultTimeout = /* @__PURE__ */ new WeakMap(), _TimeoutSettings_defaultNavigationTimeout = /* @__PURE__ */ new WeakMap();

// node_modules/puppeteer-core/lib/esm/puppeteer/common/Tracing.js
var __classPrivateFieldSet28 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet32 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Tracing_client;
var _Tracing_recording;
var _Tracing_path;
var Tracing = class {
  constructor(client) {
    _Tracing_client.set(this, void 0);
    _Tracing_recording.set(this, false);
    _Tracing_path.set(this, void 0);
    __classPrivateFieldSet28(this, _Tracing_client, client, "f");
  }
  async start(options = {}) {
    assert(!__classPrivateFieldGet32(this, _Tracing_recording, "f"), "Cannot start recording trace while already recording trace.");
    const defaultCategories = [
      "-*",
      "devtools.timeline",
      "v8.execute",
      "disabled-by-default-devtools.timeline",
      "disabled-by-default-devtools.timeline.frame",
      "toplevel",
      "blink.console",
      "blink.user_timing",
      "latencyInfo",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-v8.cpu_profiler"
    ];
    const { path, screenshots = false, categories = defaultCategories } = options;
    if (screenshots) {
      categories.push("disabled-by-default-devtools.screenshot");
    }
    const excludedCategories = categories.filter((cat) => {
      return cat.startsWith("-");
    }).map((cat) => {
      return cat.slice(1);
    });
    const includedCategories = categories.filter((cat) => {
      return !cat.startsWith("-");
    });
    __classPrivateFieldSet28(this, _Tracing_path, path, "f");
    __classPrivateFieldSet28(this, _Tracing_recording, true, "f");
    await __classPrivateFieldGet32(this, _Tracing_client, "f").send("Tracing.start", {
      transferMode: "ReturnAsStream",
      traceConfig: {
        excludedCategories,
        includedCategories
      }
    });
  }
  async stop() {
    const contentDeferred = Deferred.create();
    __classPrivateFieldGet32(this, _Tracing_client, "f").once("Tracing.tracingComplete", async (event) => {
      try {
        const readable = await getReadableFromProtocolStream(__classPrivateFieldGet32(this, _Tracing_client, "f"), event.stream);
        const buffer = await getReadableAsBuffer(readable, __classPrivateFieldGet32(this, _Tracing_path, "f"));
        contentDeferred.resolve(buffer != null ? buffer : void 0);
      } catch (error) {
        if (isErrorLike(error)) {
          contentDeferred.reject(error);
        } else {
          contentDeferred.reject(new Error(`Unknown error: ${error}`));
        }
      }
    });
    await __classPrivateFieldGet32(this, _Tracing_client, "f").send("Tracing.end");
    __classPrivateFieldSet28(this, _Tracing_recording, false, "f");
    return contentDeferred.valueOrThrow();
  }
};
_Tracing_client = /* @__PURE__ */ new WeakMap(), _Tracing_recording = /* @__PURE__ */ new WeakMap(), _Tracing_path = /* @__PURE__ */ new WeakMap();

export {
  EventEmitter,
  WEB_PERMISSION_TO_PROTOCOL_PERMISSION,
  Browser,
  BrowserContext,
  assert,
  isNode,
  CustomError,
  TimeoutError,
  ProtocolError,
  TargetCloseError,
  errors,
  Deferred,
  createDebuggableDeferred,
  DEFAULT_INTERCEPT_RESOLUTION_PRIORITY,
  HTTPRequest,
  InterceptResolutionAction,
  headersArray,
  STATUS_TEXTS,
  isErrorLike,
  isErrnoException,
  importDebug,
  debug,
  setLogCapture,
  getCapturedLogs,
  AsyncIterableUtil,
  stringifyFunction,
  LazyArg,
  QueryHandler,
  ARIAQueryHandler,
  scriptInjector,
  CustomQueryHandlerRegistry,
  customQueryHandlers,
  registerCustomQueryHandler,
  unregisterCustomQueryHandler,
  customQueryHandlerNames,
  clearCustomQueryHandlers,
  JSHandle,
  ElementHandle,
  CDPJSHandle,
  CDPElementHandle,
  debugError,
  createEvaluationError,
  createClientError,
  PuppeteerURL,
  withSourcePuppeteerURLIfNone,
  getSourcePuppeteerURLIfAvailable,
  valueFromRemoteObject,
  releaseObject,
  addEventListener,
  removeEventListeners,
  isString,
  isNumber,
  isPlainObject,
  isRegExp,
  isDate,
  waitForEvent,
  createJSHandle,
  evaluationString,
  addPageBinding,
  pageBindingInitString,
  waitWithTimeout,
  importFSPromises,
  getReadableAsBuffer,
  getReadableFromProtocolStream,
  setPageContent,
  getPageContent,
  HTTPResponse,
  SecurityDetails,
  NetworkEventManager,
  NetworkManagerEmittedEvents,
  NetworkManager,
  paperFormats,
  LocatorEmittedEvents,
  Locator,
  LocatorImpl,
  Page,
  supportedMetrics,
  unitToPixels,
  Keyboard,
  MouseButton,
  Mouse,
  Touchscreen,
  Frame,
  Accessibility,
  ConnectionEmittedEvents,
  Callback,
  CallbackRegistry,
  Connection,
  CDPSessionEmittedEvents,
  CDPSession,
  CDPSessionImpl,
  isTargetClosedError,
  Binding,
  ConsoleMessage,
  Coverage,
  JSCoverage,
  CSSCoverage,
  EmulationManager,
  DeviceRequestPromptDevice,
  DeviceRequestPrompt,
  DeviceRequestPromptManager,
  ExecutionContext,
  MAIN_WORLD,
  PUPPETEER_WORLD,
  LifecycleWatcher,
  WaitTask,
  TaskManager,
  IsolatedWorld,
  FrameTree,
  UTILITY_WORLD_NAME,
  FrameManagerEmittedEvents,
  FrameManager,
  TimeoutSettings,
  Tracing,
  require_crypto
};
//# sourceMappingURL=chunk-N6XPV5UP.js.map
